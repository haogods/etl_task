# -*- coding:utf8 -*-
#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style,utf8strings
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(object):
  def setIncSegInfo(self, accessToken, versionPolicy, incSegInfo):
    """
    设置片段信息

    Parameters:
     - accessToken
     - versionPolicy
     - incSegInfo
    """
    pass

  def getIncSegInfo(self, accessToken, versionPolicy, incSegId):
    """
    读取片段信息

    Parameters:
     - accessToken
     - versionPolicy
     - incSegId
    """
    pass

  def findIncSegInfoId(self, accessToken, versionPolicy, incSegName, incSegLocId):
    """
    通过片段名称和地区来查找片段id

    Parameters:
     - accessToken
     - versionPolicy
     - incSegName
     - incSegLocId
    """
    pass

  def setIncInfo(self, accessToken, versionPolicy, incInfo):
    """
    设置公司信息

    Parameters:
     - accessToken
     - versionPolicy
     - incInfo
    """
    pass

  def getIncInfo(self, accessToken, versionPolicy, incId):
    """
    获取公司信息

    Parameters:
     - accessToken
     - versionPolicy
     - incId
    """
    pass

  def findIncInfoId(self, accessToken, versionPolicy, incName, incLocId):
    """
    通过公司名称和地区来查找公司id

    Parameters:
     - accessToken
     - versionPolicy
     - incName
     - incLocId
    """
    pass

  def bindIncAndIncSeg(self, accessToken, versionPolicy, incId, incSegIdList):
    """
    绑定公司和片段

    Parameters:
     - accessToken
     - versionPolicy
     - incId
     - incSegIdList
    """
    pass

  def unbindIncAndIncSeg(self, accessToken, versionPolicy, incId, incSegIdList):
    """
    解绑公司和片段

    Parameters:
     - accessToken
     - versionPolicy
     - incId
     - incSegIdList
    """
    pass

  def queryIncSegIdList(self, accessToken, versionPolicy, incId):
    """
    根据公司id查询片段id

    Parameters:
     - accessToken
     - versionPolicy
     - incId
    """
    pass

  def queryIncId(self, accessToken, versionPolicy, incSegId):
    """
    根据片段id查询公司id

    Parameters:
     - accessToken
     - versionPolicy
     - incSegId
    """
    pass

  def queryCandidateIncs(self, accessToken, versionPolicy, incSegLocId, incSegFirm):
    """
    查询未绑定公司

    Parameters:
     - accessToken
     - versionPolicy
     - incSegLocId
     - incSegFirm
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def setIncSegInfo(self, accessToken, versionPolicy, incSegInfo):
    """
    设置片段信息

    Parameters:
     - accessToken
     - versionPolicy
     - incSegInfo
    """
    self.send_setIncSegInfo(accessToken, versionPolicy, incSegInfo)
    self.recv_setIncSegInfo()

  def send_setIncSegInfo(self, accessToken, versionPolicy, incSegInfo):
    self._oprot.writeMessageBegin('setIncSegInfo', TMessageType.CALL, self._seqid)
    args = setIncSegInfo_args()
    args.accessToken = accessToken
    args.versionPolicy = versionPolicy
    args.incSegInfo = incSegInfo
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setIncSegInfo(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = setIncSegInfo_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.namedError is not None:
      raise result.namedError
    return

  def getIncSegInfo(self, accessToken, versionPolicy, incSegId):
    """
    读取片段信息

    Parameters:
     - accessToken
     - versionPolicy
     - incSegId
    """
    self.send_getIncSegInfo(accessToken, versionPolicy, incSegId)
    return self.recv_getIncSegInfo()

  def send_getIncSegInfo(self, accessToken, versionPolicy, incSegId):
    self._oprot.writeMessageBegin('getIncSegInfo', TMessageType.CALL, self._seqid)
    args = getIncSegInfo_args()
    args.accessToken = accessToken
    args.versionPolicy = versionPolicy
    args.incSegId = incSegId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getIncSegInfo(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getIncSegInfo_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getIncSegInfo failed: unknown result");

  def findIncSegInfoId(self, accessToken, versionPolicy, incSegName, incSegLocId):
    """
    通过片段名称和地区来查找片段id

    Parameters:
     - accessToken
     - versionPolicy
     - incSegName
     - incSegLocId
    """
    self.send_findIncSegInfoId(accessToken, versionPolicy, incSegName, incSegLocId)
    return self.recv_findIncSegInfoId()

  def send_findIncSegInfoId(self, accessToken, versionPolicy, incSegName, incSegLocId):
    self._oprot.writeMessageBegin('findIncSegInfoId', TMessageType.CALL, self._seqid)
    args = findIncSegInfoId_args()
    args.accessToken = accessToken
    args.versionPolicy = versionPolicy
    args.incSegName = incSegName
    args.incSegLocId = incSegLocId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findIncSegInfoId(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findIncSegInfoId_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findIncSegInfoId failed: unknown result");

  def setIncInfo(self, accessToken, versionPolicy, incInfo):
    """
    设置公司信息

    Parameters:
     - accessToken
     - versionPolicy
     - incInfo
    """
    self.send_setIncInfo(accessToken, versionPolicy, incInfo)
    self.recv_setIncInfo()

  def send_setIncInfo(self, accessToken, versionPolicy, incInfo):
    self._oprot.writeMessageBegin('setIncInfo', TMessageType.CALL, self._seqid)
    args = setIncInfo_args()
    args.accessToken = accessToken
    args.versionPolicy = versionPolicy
    args.incInfo = incInfo
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setIncInfo(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = setIncInfo_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.namedError is not None:
      raise result.namedError
    return

  def getIncInfo(self, accessToken, versionPolicy, incId):
    """
    获取公司信息

    Parameters:
     - accessToken
     - versionPolicy
     - incId
    """
    self.send_getIncInfo(accessToken, versionPolicy, incId)
    return self.recv_getIncInfo()

  def send_getIncInfo(self, accessToken, versionPolicy, incId):
    self._oprot.writeMessageBegin('getIncInfo', TMessageType.CALL, self._seqid)
    args = getIncInfo_args()
    args.accessToken = accessToken
    args.versionPolicy = versionPolicy
    args.incId = incId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getIncInfo(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getIncInfo_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getIncInfo failed: unknown result");

  def findIncInfoId(self, accessToken, versionPolicy, incName, incLocId):
    """
    通过公司名称和地区来查找公司id

    Parameters:
     - accessToken
     - versionPolicy
     - incName
     - incLocId
    """
    self.send_findIncInfoId(accessToken, versionPolicy, incName, incLocId)
    return self.recv_findIncInfoId()

  def send_findIncInfoId(self, accessToken, versionPolicy, incName, incLocId):
    self._oprot.writeMessageBegin('findIncInfoId', TMessageType.CALL, self._seqid)
    args = findIncInfoId_args()
    args.accessToken = accessToken
    args.versionPolicy = versionPolicy
    args.incName = incName
    args.incLocId = incLocId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findIncInfoId(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findIncInfoId_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findIncInfoId failed: unknown result");

  def bindIncAndIncSeg(self, accessToken, versionPolicy, incId, incSegIdList):
    """
    绑定公司和片段

    Parameters:
     - accessToken
     - versionPolicy
     - incId
     - incSegIdList
    """
    self.send_bindIncAndIncSeg(accessToken, versionPolicy, incId, incSegIdList)
    self.recv_bindIncAndIncSeg()

  def send_bindIncAndIncSeg(self, accessToken, versionPolicy, incId, incSegIdList):
    self._oprot.writeMessageBegin('bindIncAndIncSeg', TMessageType.CALL, self._seqid)
    args = bindIncAndIncSeg_args()
    args.accessToken = accessToken
    args.versionPolicy = versionPolicy
    args.incId = incId
    args.incSegIdList = incSegIdList
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bindIncAndIncSeg(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = bindIncAndIncSeg_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.namedError is not None:
      raise result.namedError
    return

  def unbindIncAndIncSeg(self, accessToken, versionPolicy, incId, incSegIdList):
    """
    解绑公司和片段

    Parameters:
     - accessToken
     - versionPolicy
     - incId
     - incSegIdList
    """
    self.send_unbindIncAndIncSeg(accessToken, versionPolicy, incId, incSegIdList)
    self.recv_unbindIncAndIncSeg()

  def send_unbindIncAndIncSeg(self, accessToken, versionPolicy, incId, incSegIdList):
    self._oprot.writeMessageBegin('unbindIncAndIncSeg', TMessageType.CALL, self._seqid)
    args = unbindIncAndIncSeg_args()
    args.accessToken = accessToken
    args.versionPolicy = versionPolicy
    args.incId = incId
    args.incSegIdList = incSegIdList
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_unbindIncAndIncSeg(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = unbindIncAndIncSeg_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.namedError is not None:
      raise result.namedError
    return

  def queryIncSegIdList(self, accessToken, versionPolicy, incId):
    """
    根据公司id查询片段id

    Parameters:
     - accessToken
     - versionPolicy
     - incId
    """
    self.send_queryIncSegIdList(accessToken, versionPolicy, incId)
    return self.recv_queryIncSegIdList()

  def send_queryIncSegIdList(self, accessToken, versionPolicy, incId):
    self._oprot.writeMessageBegin('queryIncSegIdList', TMessageType.CALL, self._seqid)
    args = queryIncSegIdList_args()
    args.accessToken = accessToken
    args.versionPolicy = versionPolicy
    args.incId = incId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_queryIncSegIdList(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = queryIncSegIdList_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "queryIncSegIdList failed: unknown result");

  def queryIncId(self, accessToken, versionPolicy, incSegId):
    """
    根据片段id查询公司id

    Parameters:
     - accessToken
     - versionPolicy
     - incSegId
    """
    self.send_queryIncId(accessToken, versionPolicy, incSegId)
    return self.recv_queryIncId()

  def send_queryIncId(self, accessToken, versionPolicy, incSegId):
    self._oprot.writeMessageBegin('queryIncId', TMessageType.CALL, self._seqid)
    args = queryIncId_args()
    args.accessToken = accessToken
    args.versionPolicy = versionPolicy
    args.incSegId = incSegId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_queryIncId(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = queryIncId_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "queryIncId failed: unknown result");

  def queryCandidateIncs(self, accessToken, versionPolicy, incSegLocId, incSegFirm):
    """
    查询未绑定公司

    Parameters:
     - accessToken
     - versionPolicy
     - incSegLocId
     - incSegFirm
    """
    self.send_queryCandidateIncs(accessToken, versionPolicy, incSegLocId, incSegFirm)
    return self.recv_queryCandidateIncs()

  def send_queryCandidateIncs(self, accessToken, versionPolicy, incSegLocId, incSegFirm):
    self._oprot.writeMessageBegin('queryCandidateIncs', TMessageType.CALL, self._seqid)
    args = queryCandidateIncs_args()
    args.accessToken = accessToken
    args.versionPolicy = versionPolicy
    args.incSegLocId = incSegLocId
    args.incSegFirm = incSegFirm
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_queryCandidateIncs(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = queryCandidateIncs_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "queryCandidateIncs failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["setIncSegInfo"] = Processor.process_setIncSegInfo
    self._processMap["getIncSegInfo"] = Processor.process_getIncSegInfo
    self._processMap["findIncSegInfoId"] = Processor.process_findIncSegInfoId
    self._processMap["setIncInfo"] = Processor.process_setIncInfo
    self._processMap["getIncInfo"] = Processor.process_getIncInfo
    self._processMap["findIncInfoId"] = Processor.process_findIncInfoId
    self._processMap["bindIncAndIncSeg"] = Processor.process_bindIncAndIncSeg
    self._processMap["unbindIncAndIncSeg"] = Processor.process_unbindIncAndIncSeg
    self._processMap["queryIncSegIdList"] = Processor.process_queryIncSegIdList
    self._processMap["queryIncId"] = Processor.process_queryIncId
    self._processMap["queryCandidateIncs"] = Processor.process_queryCandidateIncs

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_setIncSegInfo(self, seqid, iprot, oprot):
    args = setIncSegInfo_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setIncSegInfo_result()
    try:
      self._handler.setIncSegInfo(args.accessToken, args.versionPolicy, args.incSegInfo)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("setIncSegInfo", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getIncSegInfo(self, seqid, iprot, oprot):
    args = getIncSegInfo_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getIncSegInfo_result()
    try:
      result.success = self._handler.getIncSegInfo(args.accessToken, args.versionPolicy, args.incSegId)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("getIncSegInfo", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findIncSegInfoId(self, seqid, iprot, oprot):
    args = findIncSegInfoId_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findIncSegInfoId_result()
    try:
      result.success = self._handler.findIncSegInfoId(args.accessToken, args.versionPolicy, args.incSegName, args.incSegLocId)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("findIncSegInfoId", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setIncInfo(self, seqid, iprot, oprot):
    args = setIncInfo_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setIncInfo_result()
    try:
      self._handler.setIncInfo(args.accessToken, args.versionPolicy, args.incInfo)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("setIncInfo", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getIncInfo(self, seqid, iprot, oprot):
    args = getIncInfo_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getIncInfo_result()
    try:
      result.success = self._handler.getIncInfo(args.accessToken, args.versionPolicy, args.incId)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("getIncInfo", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findIncInfoId(self, seqid, iprot, oprot):
    args = findIncInfoId_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findIncInfoId_result()
    try:
      result.success = self._handler.findIncInfoId(args.accessToken, args.versionPolicy, args.incName, args.incLocId)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("findIncInfoId", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bindIncAndIncSeg(self, seqid, iprot, oprot):
    args = bindIncAndIncSeg_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bindIncAndIncSeg_result()
    try:
      self._handler.bindIncAndIncSeg(args.accessToken, args.versionPolicy, args.incId, args.incSegIdList)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("bindIncAndIncSeg", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_unbindIncAndIncSeg(self, seqid, iprot, oprot):
    args = unbindIncAndIncSeg_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = unbindIncAndIncSeg_result()
    try:
      self._handler.unbindIncAndIncSeg(args.accessToken, args.versionPolicy, args.incId, args.incSegIdList)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("unbindIncAndIncSeg", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_queryIncSegIdList(self, seqid, iprot, oprot):
    args = queryIncSegIdList_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = queryIncSegIdList_result()
    try:
      result.success = self._handler.queryIncSegIdList(args.accessToken, args.versionPolicy, args.incId)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("queryIncSegIdList", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_queryIncId(self, seqid, iprot, oprot):
    args = queryIncId_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = queryIncId_result()
    try:
      result.success = self._handler.queryIncId(args.accessToken, args.versionPolicy, args.incSegId)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("queryIncId", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_queryCandidateIncs(self, seqid, iprot, oprot):
    args = queryCandidateIncs_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = queryCandidateIncs_result()
    try:
      result.success = self._handler.queryCandidateIncs(args.accessToken, args.versionPolicy, args.incSegLocId, args.incSegFirm)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("queryCandidateIncs", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class setIncSegInfo_args(object):
  """
  Attributes:
   - accessToken
   - versionPolicy
   - incSegInfo
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (ipin.rpc.common.datatype.ttypes.ServiceAccessToken, ipin.rpc.common.datatype.ttypes.ServiceAccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'versionPolicy', None, None, ), # 2
    (3, TType.STRUCT, 'incSegInfo', (IncSegInfo, IncSegInfo.thrift_spec), None, ), # 3
  )

  def __init__(self, accessToken=None, versionPolicy=None, incSegInfo=None,):
    self.accessToken = accessToken
    self.versionPolicy = versionPolicy
    self.incSegInfo = incSegInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = ipin.rpc.common.datatype.ttypes.ServiceAccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.versionPolicy = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.incSegInfo = IncSegInfo()
          self.incSegInfo.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setIncSegInfo_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    if self.versionPolicy is not None:
      oprot.writeFieldBegin('versionPolicy', TType.STRING, 2)
      oprot.writeString(self.versionPolicy.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.incSegInfo is not None:
      oprot.writeFieldBegin('incSegInfo', TType.STRUCT, 3)
      self.incSegInfo.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.accessToken)
    value = (value * 31) ^ hash(self.versionPolicy)
    value = (value * 31) ^ hash(self.incSegInfo)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setIncSegInfo_result(object):
  """
  Attributes:
   - namedError
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, namedError=None,):
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setIncSegInfo_result')
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getIncSegInfo_args(object):
  """
  Attributes:
   - accessToken
   - versionPolicy
   - incSegId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (ipin.rpc.common.datatype.ttypes.ServiceAccessToken, ipin.rpc.common.datatype.ttypes.ServiceAccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'versionPolicy', None, None, ), # 2
    (3, TType.STRING, 'incSegId', None, None, ), # 3
  )

  def __init__(self, accessToken=None, versionPolicy=None, incSegId=None,):
    self.accessToken = accessToken
    self.versionPolicy = versionPolicy
    self.incSegId = incSegId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = ipin.rpc.common.datatype.ttypes.ServiceAccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.versionPolicy = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.incSegId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getIncSegInfo_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    if self.versionPolicy is not None:
      oprot.writeFieldBegin('versionPolicy', TType.STRING, 2)
      oprot.writeString(self.versionPolicy.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.incSegId is not None:
      oprot.writeFieldBegin('incSegId', TType.STRING, 3)
      oprot.writeString(self.incSegId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.accessToken)
    value = (value * 31) ^ hash(self.versionPolicy)
    value = (value * 31) ^ hash(self.incSegId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getIncSegInfo_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (IncSegInfo, IncSegInfo.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = IncSegInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getIncSegInfo_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findIncSegInfoId_args(object):
  """
  Attributes:
   - accessToken
   - versionPolicy
   - incSegName
   - incSegLocId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (ipin.rpc.common.datatype.ttypes.ServiceAccessToken, ipin.rpc.common.datatype.ttypes.ServiceAccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'versionPolicy', None, None, ), # 2
    (3, TType.STRING, 'incSegName', None, None, ), # 3
    (4, TType.STRING, 'incSegLocId', None, None, ), # 4
  )

  def __init__(self, accessToken=None, versionPolicy=None, incSegName=None, incSegLocId=None,):
    self.accessToken = accessToken
    self.versionPolicy = versionPolicy
    self.incSegName = incSegName
    self.incSegLocId = incSegLocId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = ipin.rpc.common.datatype.ttypes.ServiceAccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.versionPolicy = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.incSegName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.incSegLocId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findIncSegInfoId_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    if self.versionPolicy is not None:
      oprot.writeFieldBegin('versionPolicy', TType.STRING, 2)
      oprot.writeString(self.versionPolicy.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.incSegName is not None:
      oprot.writeFieldBegin('incSegName', TType.STRING, 3)
      oprot.writeString(self.incSegName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.incSegLocId is not None:
      oprot.writeFieldBegin('incSegLocId', TType.STRING, 4)
      oprot.writeString(self.incSegLocId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.accessToken)
    value = (value * 31) ^ hash(self.versionPolicy)
    value = (value * 31) ^ hash(self.incSegName)
    value = (value * 31) ^ hash(self.incSegLocId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findIncSegInfoId_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findIncSegInfoId_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setIncInfo_args(object):
  """
  Attributes:
   - accessToken
   - versionPolicy
   - incInfo
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (ipin.rpc.common.datatype.ttypes.ServiceAccessToken, ipin.rpc.common.datatype.ttypes.ServiceAccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'versionPolicy', None, None, ), # 2
    (3, TType.STRUCT, 'incInfo', (IncInfo, IncInfo.thrift_spec), None, ), # 3
  )

  def __init__(self, accessToken=None, versionPolicy=None, incInfo=None,):
    self.accessToken = accessToken
    self.versionPolicy = versionPolicy
    self.incInfo = incInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = ipin.rpc.common.datatype.ttypes.ServiceAccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.versionPolicy = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.incInfo = IncInfo()
          self.incInfo.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setIncInfo_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    if self.versionPolicy is not None:
      oprot.writeFieldBegin('versionPolicy', TType.STRING, 2)
      oprot.writeString(self.versionPolicy.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.incInfo is not None:
      oprot.writeFieldBegin('incInfo', TType.STRUCT, 3)
      self.incInfo.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.accessToken)
    value = (value * 31) ^ hash(self.versionPolicy)
    value = (value * 31) ^ hash(self.incInfo)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setIncInfo_result(object):
  """
  Attributes:
   - namedError
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, namedError=None,):
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setIncInfo_result')
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getIncInfo_args(object):
  """
  Attributes:
   - accessToken
   - versionPolicy
   - incId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (ipin.rpc.common.datatype.ttypes.ServiceAccessToken, ipin.rpc.common.datatype.ttypes.ServiceAccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'versionPolicy', None, None, ), # 2
    (3, TType.STRING, 'incId', None, None, ), # 3
  )

  def __init__(self, accessToken=None, versionPolicy=None, incId=None,):
    self.accessToken = accessToken
    self.versionPolicy = versionPolicy
    self.incId = incId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = ipin.rpc.common.datatype.ttypes.ServiceAccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.versionPolicy = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.incId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getIncInfo_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    if self.versionPolicy is not None:
      oprot.writeFieldBegin('versionPolicy', TType.STRING, 2)
      oprot.writeString(self.versionPolicy.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.incId is not None:
      oprot.writeFieldBegin('incId', TType.STRING, 3)
      oprot.writeString(self.incId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.accessToken)
    value = (value * 31) ^ hash(self.versionPolicy)
    value = (value * 31) ^ hash(self.incId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getIncInfo_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (IncInfo, IncInfo.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = IncInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getIncInfo_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findIncInfoId_args(object):
  """
  Attributes:
   - accessToken
   - versionPolicy
   - incName
   - incLocId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (ipin.rpc.common.datatype.ttypes.ServiceAccessToken, ipin.rpc.common.datatype.ttypes.ServiceAccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'versionPolicy', None, None, ), # 2
    (3, TType.STRING, 'incName', None, None, ), # 3
    (4, TType.STRING, 'incLocId', None, None, ), # 4
  )

  def __init__(self, accessToken=None, versionPolicy=None, incName=None, incLocId=None,):
    self.accessToken = accessToken
    self.versionPolicy = versionPolicy
    self.incName = incName
    self.incLocId = incLocId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = ipin.rpc.common.datatype.ttypes.ServiceAccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.versionPolicy = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.incName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.incLocId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findIncInfoId_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    if self.versionPolicy is not None:
      oprot.writeFieldBegin('versionPolicy', TType.STRING, 2)
      oprot.writeString(self.versionPolicy.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.incName is not None:
      oprot.writeFieldBegin('incName', TType.STRING, 3)
      oprot.writeString(self.incName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.incLocId is not None:
      oprot.writeFieldBegin('incLocId', TType.STRING, 4)
      oprot.writeString(self.incLocId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.accessToken)
    value = (value * 31) ^ hash(self.versionPolicy)
    value = (value * 31) ^ hash(self.incName)
    value = (value * 31) ^ hash(self.incLocId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findIncInfoId_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findIncInfoId_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bindIncAndIncSeg_args(object):
  """
  Attributes:
   - accessToken
   - versionPolicy
   - incId
   - incSegIdList
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (ipin.rpc.common.datatype.ttypes.ServiceAccessToken, ipin.rpc.common.datatype.ttypes.ServiceAccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'versionPolicy', None, None, ), # 2
    (3, TType.STRING, 'incId', None, None, ), # 3
    (4, TType.LIST, 'incSegIdList', (TType.STRING,None), None, ), # 4
  )

  def __init__(self, accessToken=None, versionPolicy=None, incId=None, incSegIdList=None,):
    self.accessToken = accessToken
    self.versionPolicy = versionPolicy
    self.incId = incId
    self.incSegIdList = incSegIdList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = ipin.rpc.common.datatype.ttypes.ServiceAccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.versionPolicy = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.incId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.incSegIdList = []
          (_etype21, _size18) = iprot.readListBegin()
          for _i22 in xrange(_size18):
            _elem23 = iprot.readString().decode('utf-8')
            self.incSegIdList.append(_elem23)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bindIncAndIncSeg_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    if self.versionPolicy is not None:
      oprot.writeFieldBegin('versionPolicy', TType.STRING, 2)
      oprot.writeString(self.versionPolicy.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.incId is not None:
      oprot.writeFieldBegin('incId', TType.STRING, 3)
      oprot.writeString(self.incId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.incSegIdList is not None:
      oprot.writeFieldBegin('incSegIdList', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.incSegIdList))
      for iter24 in self.incSegIdList:
        oprot.writeString(iter24.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.accessToken)
    value = (value * 31) ^ hash(self.versionPolicy)
    value = (value * 31) ^ hash(self.incId)
    value = (value * 31) ^ hash(self.incSegIdList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bindIncAndIncSeg_result(object):
  """
  Attributes:
   - namedError
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, namedError=None,):
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bindIncAndIncSeg_result')
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unbindIncAndIncSeg_args(object):
  """
  Attributes:
   - accessToken
   - versionPolicy
   - incId
   - incSegIdList
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (ipin.rpc.common.datatype.ttypes.ServiceAccessToken, ipin.rpc.common.datatype.ttypes.ServiceAccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'versionPolicy', None, None, ), # 2
    (3, TType.STRING, 'incId', None, None, ), # 3
    (4, TType.LIST, 'incSegIdList', (TType.STRING,None), None, ), # 4
  )

  def __init__(self, accessToken=None, versionPolicy=None, incId=None, incSegIdList=None,):
    self.accessToken = accessToken
    self.versionPolicy = versionPolicy
    self.incId = incId
    self.incSegIdList = incSegIdList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = ipin.rpc.common.datatype.ttypes.ServiceAccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.versionPolicy = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.incId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.incSegIdList = []
          (_etype28, _size25) = iprot.readListBegin()
          for _i29 in xrange(_size25):
            _elem30 = iprot.readString().decode('utf-8')
            self.incSegIdList.append(_elem30)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unbindIncAndIncSeg_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    if self.versionPolicy is not None:
      oprot.writeFieldBegin('versionPolicy', TType.STRING, 2)
      oprot.writeString(self.versionPolicy.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.incId is not None:
      oprot.writeFieldBegin('incId', TType.STRING, 3)
      oprot.writeString(self.incId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.incSegIdList is not None:
      oprot.writeFieldBegin('incSegIdList', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.incSegIdList))
      for iter31 in self.incSegIdList:
        oprot.writeString(iter31.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.accessToken)
    value = (value * 31) ^ hash(self.versionPolicy)
    value = (value * 31) ^ hash(self.incId)
    value = (value * 31) ^ hash(self.incSegIdList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unbindIncAndIncSeg_result(object):
  """
  Attributes:
   - namedError
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, namedError=None,):
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unbindIncAndIncSeg_result')
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class queryIncSegIdList_args(object):
  """
  Attributes:
   - accessToken
   - versionPolicy
   - incId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (ipin.rpc.common.datatype.ttypes.ServiceAccessToken, ipin.rpc.common.datatype.ttypes.ServiceAccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'versionPolicy', None, None, ), # 2
    (3, TType.STRING, 'incId', None, None, ), # 3
  )

  def __init__(self, accessToken=None, versionPolicy=None, incId=None,):
    self.accessToken = accessToken
    self.versionPolicy = versionPolicy
    self.incId = incId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = ipin.rpc.common.datatype.ttypes.ServiceAccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.versionPolicy = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.incId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('queryIncSegIdList_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    if self.versionPolicy is not None:
      oprot.writeFieldBegin('versionPolicy', TType.STRING, 2)
      oprot.writeString(self.versionPolicy.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.incId is not None:
      oprot.writeFieldBegin('incId', TType.STRING, 3)
      oprot.writeString(self.incId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.accessToken)
    value = (value * 31) ^ hash(self.versionPolicy)
    value = (value * 31) ^ hash(self.incId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class queryIncSegIdList_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype35, _size32) = iprot.readListBegin()
          for _i36 in xrange(_size32):
            _elem37 = iprot.readString().decode('utf-8')
            self.success.append(_elem37)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('queryIncSegIdList_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter38 in self.success:
        oprot.writeString(iter38.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class queryIncId_args(object):
  """
  Attributes:
   - accessToken
   - versionPolicy
   - incSegId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (ipin.rpc.common.datatype.ttypes.ServiceAccessToken, ipin.rpc.common.datatype.ttypes.ServiceAccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'versionPolicy', None, None, ), # 2
    (3, TType.STRING, 'incSegId', None, None, ), # 3
  )

  def __init__(self, accessToken=None, versionPolicy=None, incSegId=None,):
    self.accessToken = accessToken
    self.versionPolicy = versionPolicy
    self.incSegId = incSegId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = ipin.rpc.common.datatype.ttypes.ServiceAccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.versionPolicy = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.incSegId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('queryIncId_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    if self.versionPolicy is not None:
      oprot.writeFieldBegin('versionPolicy', TType.STRING, 2)
      oprot.writeString(self.versionPolicy.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.incSegId is not None:
      oprot.writeFieldBegin('incSegId', TType.STRING, 3)
      oprot.writeString(self.incSegId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.accessToken)
    value = (value * 31) ^ hash(self.versionPolicy)
    value = (value * 31) ^ hash(self.incSegId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class queryIncId_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('queryIncId_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class queryCandidateIncs_args(object):
  """
  Attributes:
   - accessToken
   - versionPolicy
   - incSegLocId
   - incSegFirm
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'accessToken', (ipin.rpc.common.datatype.ttypes.ServiceAccessToken, ipin.rpc.common.datatype.ttypes.ServiceAccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'versionPolicy', None, None, ), # 2
    (3, TType.STRING, 'incSegLocId', None, None, ), # 3
    (4, TType.STRING, 'incSegFirm', None, None, ), # 4
  )

  def __init__(self, accessToken=None, versionPolicy=None, incSegLocId=None, incSegFirm=None,):
    self.accessToken = accessToken
    self.versionPolicy = versionPolicy
    self.incSegLocId = incSegLocId
    self.incSegFirm = incSegFirm

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.accessToken = ipin.rpc.common.datatype.ttypes.ServiceAccessToken()
          self.accessToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.versionPolicy = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.incSegLocId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.incSegFirm = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('queryCandidateIncs_args')
    if self.accessToken is not None:
      oprot.writeFieldBegin('accessToken', TType.STRUCT, 1)
      self.accessToken.write(oprot)
      oprot.writeFieldEnd()
    if self.versionPolicy is not None:
      oprot.writeFieldBegin('versionPolicy', TType.STRING, 2)
      oprot.writeString(self.versionPolicy.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.incSegLocId is not None:
      oprot.writeFieldBegin('incSegLocId', TType.STRING, 3)
      oprot.writeString(self.incSegLocId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.incSegFirm is not None:
      oprot.writeFieldBegin('incSegFirm', TType.STRING, 4)
      oprot.writeString(self.incSegFirm.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.accessToken)
    value = (value * 31) ^ hash(self.versionPolicy)
    value = (value * 31) ^ hash(self.incSegLocId)
    value = (value * 31) ^ hash(self.incSegFirm)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class queryCandidateIncs_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(IncInfo, IncInfo.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype42, _size39) = iprot.readListBegin()
          for _i43 in xrange(_size39):
            _elem44 = IncInfo()
            _elem44.read(iprot)
            self.success.append(_elem44)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('queryCandidateIncs_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter45 in self.success:
        iter45.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
