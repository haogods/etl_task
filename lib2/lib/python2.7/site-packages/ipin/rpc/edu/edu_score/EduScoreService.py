# -*- coding:utf8 -*-
#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style,utf8strings
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(object):
  def setProvinceToudangScore(self, versionName, pts):
    """
    设置省份投档线

    Parameters:
     - versionName
     - pts
    """
    pass

  def getProvinceToudangScore(self, versionName, year, provinceId, eduTypeWenli, batch):
    """
    获取省份投档线

    Parameters:
     - versionName
     - year
     - provinceId
     - eduTypeWenli
     - batch
    """
    pass

  def listAllProvinceToudangScore(self, versionName):
    """
    列出所有省控线

    Parameters:
     - versionName
    """
    pass

  def listProvinceToudangScore(self, versionName, year, eduTypeWenli, batch):
    """
    按年份，文理科，批次 列出省份投档线

    Parameters:
     - versionName
     - year
     - eduTypeWenli
     - batch
    """
    pass

  def listProvinceToudangScoreByProvince(self, versionName, year, provinceId, eduTypeWenli):
    """
    按年份，文理科,省份列出投档线

    Parameters:
     - versionName
     - year
     - provinceId
     - eduTypeWenli
    """
    pass

  def setProvinceGaokaoStat(self, versionName, stat):
    """
    设置省份高考分数统计

    Parameters:
     - versionName
     - stat
    """
    pass

  def listProvinceGaokaoStat(self, versionName, provinceId, eduTypeWenli, year, fromScore, toScore):
    """
    按省份，文理科，分数区间 列出省份分数统计

    Parameters:
     - versionName
     - provinceId
     - eduTypeWenli
     - year
     - fromScore
     - toScore
    """
    pass

  def getProvinceScoreDist(self, versionName, provinceId, eduTypeWenli, year):
    """
    获取分数分布

    Parameters:
     - versionName
     - provinceId
     - eduTypeWenli
     - year
    """
    pass

  def setGaokaoPeopleCount(self, versionName, pc):
    """
    设置省份人数

    Parameters:
     - versionName
     - pc
    """
    pass

  def getGaokaoPeopleCount(self, versionName, provinceId, eduTypeWenli, year):
    """
    获取省份人数

    Parameters:
     - versionName
     - provinceId
     - eduTypeWenli
     - year
    """
    pass

  def setSchScoreStat(self, versionName, stat):
    """
    设置学校分数统计

    Parameters:
     - versionName
     - stat
    """
    pass

  def listSchScoreStat(self, versionName, eduTypeWenli, year, batch, fromProvinceId):
    """
    按文理科，年份，批次，考试省份 列出 学校分数统计

    Parameters:
     - versionName
     - eduTypeWenli
     - year
     - batch
     - fromProvinceId
    """
    pass

  def listSchScoreStatBySchId(self, versionName, schId):
    """
    Parameters:
     - versionName
     - schId
    """
    pass

  def listAllSchScoreStat(self, versionName):
    """
    列出所有学校分数统计

    Parameters:
     - versionName
    """
    pass

  def setSchMajorScoreStat(self, versionName, stat):
    """
    设置学校专业分数统计

    Parameters:
     - versionName
     - stat
    """
    pass

  def listSchMajorScoreStat(self, versionName, eduTypeWenli, year, batch, fromProvinceId, schId):
    """
    按文理科，年份，批次，考试省份,学校 列出 学校专业分数

    Parameters:
     - versionName
     - eduTypeWenli
     - year
     - batch
     - fromProvinceId
     - schId
    """
    pass

  def listSchMajorScoreStatListBySchMajor(self, versionName, schId, majorId):
    """
    按学校，专业列出分数

    Parameters:
     - versionName
     - schId
     - majorId
    """
    pass

  def listSchMajorScoreStatListBySch(self, versionName, schId):
    """
    按学校列出分数

    Parameters:
     - versionName
     - schId
    """
    pass

  def getSchStat(self, versionName, eduTypeWenli, batch, fromProvinceId, schId, sizeRange):
    """
    按 文理 批次 省份(地区、全国) 学校id 列出学校不分年份的统计信息
    省份： id
    地区： region_XXX
    全国： -1

    Parameters:
     - versionName
     - eduTypeWenli
     - batch
     - fromProvinceId
     - schId
     - sizeRange
    """
    pass

  def listSchStatBySch(self, versionName, SchId):
    """
    Parameters:
     - versionName
     - SchId
    """
    pass

  def setSchStat(self, versionName, stat):
    """
    按 文理 批次 省份(地区、全国) 学校id 设置学校不分年份的统计信息
    省份： id
    地区： region_XXX
    全国： -1

    Parameters:
     - versionName
     - stat
    """
    pass

  def getSchCluster(self, versionName, eduTypeWenli, batch, fromProvinceId, schoolLocation, sizeRange):
    """
    按 文理 批次 生源地 学校地区 学校人数 列出学校的聚类统计

    Parameters:
     - versionName
     - eduTypeWenli
     - batch
     - fromProvinceId
     - schoolLocation
     - sizeRange
    """
    pass

  def setSchCluster(self, versionName, cluster):
    """
    按 文理 批次 生源地 学校地区 学校人数 设置学校的聚类统计

    Parameters:
     - versionName
     - cluster
    """
    pass

  def listSchClusterByFromProvince(self, versionName, fromProvinceId):
    """
    Parameters:
     - versionName
     - fromProvinceId
    """
    pass

  def getProvinceScoreRankByScore(self, versionName, provinceId, year, eduTypeWenli, score):
    """
    按 省份 年份 文理 分数 获得排名


    Parameters:
     - versionName
     - provinceId
     - year
     - eduTypeWenli
     - score
    """
    pass

  def getProvinceScoreRankByRank(self, versionName, provinceId, year, eduTypeWenli, rank):
    """
    Parameters:
     - versionName
     - provinceId
     - year
     - eduTypeWenli
     - rank
    """
    pass

  def listProvinceScoreRank(self, versionName, provinceId, year, eduTypeWenli):
    """
    Parameters:
     - versionName
     - provinceId
     - year
     - eduTypeWenli
    """
    pass

  def setProvinceScoreRank(self, versionName, provinceScoreRank):
    """
    Parameters:
     - versionName
     - provinceScoreRank
    """
    pass

  def getSchMeanAndStdev(self, versionName, fromProvinceId, schId, eduTypeWenli, batch):
    """
    按 生源地 学校ID 文理 批次 获得学校的统计信息

    Parameters:
     - versionName
     - fromProvinceId
     - schId
     - eduTypeWenli
     - batch
    """
    pass

  def listSchMeanAndStdev(self, versionName, fromProvinceId, eduTypeWenli, batch):
    """
    Parameters:
     - versionName
     - fromProvinceId
     - eduTypeWenli
     - batch
    """
    pass

  def setSchMeanAndStdev(self, versionName, stat):
    """
    Parameters:
     - versionName
     - stat
    """
    pass

  def getSameScoreStat(self, versionName, fromProvinceId, eduTypeWenli, batch, year, score, schId, majorId):
    """
    获取同分考试去向信息，包括学校、专业


    Parameters:
     - versionName
     - fromProvinceId
     - eduTypeWenli
     - batch
     - year
     - score
     - schId
     - majorId
    """
    pass

  def listSameScoreStat(self, versionName, fromProvinceId, eduTypeWenli, batch, year, score):
    """
    Parameters:
     - versionName
     - fromProvinceId
     - eduTypeWenli
     - batch
     - year
     - score
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def setProvinceToudangScore(self, versionName, pts):
    """
    设置省份投档线

    Parameters:
     - versionName
     - pts
    """
    self.send_setProvinceToudangScore(versionName, pts)
    self.recv_setProvinceToudangScore()

  def send_setProvinceToudangScore(self, versionName, pts):
    self._oprot.writeMessageBegin('setProvinceToudangScore', TMessageType.CALL, self._seqid)
    args = setProvinceToudangScore_args()
    args.versionName = versionName
    args.pts = pts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setProvinceToudangScore(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = setProvinceToudangScore_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.namedError is not None:
      raise result.namedError
    return

  def getProvinceToudangScore(self, versionName, year, provinceId, eduTypeWenli, batch):
    """
    获取省份投档线

    Parameters:
     - versionName
     - year
     - provinceId
     - eduTypeWenli
     - batch
    """
    self.send_getProvinceToudangScore(versionName, year, provinceId, eduTypeWenli, batch)
    return self.recv_getProvinceToudangScore()

  def send_getProvinceToudangScore(self, versionName, year, provinceId, eduTypeWenli, batch):
    self._oprot.writeMessageBegin('getProvinceToudangScore', TMessageType.CALL, self._seqid)
    args = getProvinceToudangScore_args()
    args.versionName = versionName
    args.year = year
    args.provinceId = provinceId
    args.eduTypeWenli = eduTypeWenli
    args.batch = batch
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getProvinceToudangScore(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getProvinceToudangScore_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getProvinceToudangScore failed: unknown result");

  def listAllProvinceToudangScore(self, versionName):
    """
    列出所有省控线

    Parameters:
     - versionName
    """
    self.send_listAllProvinceToudangScore(versionName)
    return self.recv_listAllProvinceToudangScore()

  def send_listAllProvinceToudangScore(self, versionName):
    self._oprot.writeMessageBegin('listAllProvinceToudangScore', TMessageType.CALL, self._seqid)
    args = listAllProvinceToudangScore_args()
    args.versionName = versionName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listAllProvinceToudangScore(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = listAllProvinceToudangScore_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listAllProvinceToudangScore failed: unknown result");

  def listProvinceToudangScore(self, versionName, year, eduTypeWenli, batch):
    """
    按年份，文理科，批次 列出省份投档线

    Parameters:
     - versionName
     - year
     - eduTypeWenli
     - batch
    """
    self.send_listProvinceToudangScore(versionName, year, eduTypeWenli, batch)
    return self.recv_listProvinceToudangScore()

  def send_listProvinceToudangScore(self, versionName, year, eduTypeWenli, batch):
    self._oprot.writeMessageBegin('listProvinceToudangScore', TMessageType.CALL, self._seqid)
    args = listProvinceToudangScore_args()
    args.versionName = versionName
    args.year = year
    args.eduTypeWenli = eduTypeWenli
    args.batch = batch
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listProvinceToudangScore(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = listProvinceToudangScore_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listProvinceToudangScore failed: unknown result");

  def listProvinceToudangScoreByProvince(self, versionName, year, provinceId, eduTypeWenli):
    """
    按年份，文理科,省份列出投档线

    Parameters:
     - versionName
     - year
     - provinceId
     - eduTypeWenli
    """
    self.send_listProvinceToudangScoreByProvince(versionName, year, provinceId, eduTypeWenli)
    return self.recv_listProvinceToudangScoreByProvince()

  def send_listProvinceToudangScoreByProvince(self, versionName, year, provinceId, eduTypeWenli):
    self._oprot.writeMessageBegin('listProvinceToudangScoreByProvince', TMessageType.CALL, self._seqid)
    args = listProvinceToudangScoreByProvince_args()
    args.versionName = versionName
    args.year = year
    args.provinceId = provinceId
    args.eduTypeWenli = eduTypeWenli
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listProvinceToudangScoreByProvince(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = listProvinceToudangScoreByProvince_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listProvinceToudangScoreByProvince failed: unknown result");

  def setProvinceGaokaoStat(self, versionName, stat):
    """
    设置省份高考分数统计

    Parameters:
     - versionName
     - stat
    """
    self.send_setProvinceGaokaoStat(versionName, stat)
    self.recv_setProvinceGaokaoStat()

  def send_setProvinceGaokaoStat(self, versionName, stat):
    self._oprot.writeMessageBegin('setProvinceGaokaoStat', TMessageType.CALL, self._seqid)
    args = setProvinceGaokaoStat_args()
    args.versionName = versionName
    args.stat = stat
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setProvinceGaokaoStat(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = setProvinceGaokaoStat_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.namedError is not None:
      raise result.namedError
    return

  def listProvinceGaokaoStat(self, versionName, provinceId, eduTypeWenli, year, fromScore, toScore):
    """
    按省份，文理科，分数区间 列出省份分数统计

    Parameters:
     - versionName
     - provinceId
     - eduTypeWenli
     - year
     - fromScore
     - toScore
    """
    self.send_listProvinceGaokaoStat(versionName, provinceId, eduTypeWenli, year, fromScore, toScore)
    return self.recv_listProvinceGaokaoStat()

  def send_listProvinceGaokaoStat(self, versionName, provinceId, eduTypeWenli, year, fromScore, toScore):
    self._oprot.writeMessageBegin('listProvinceGaokaoStat', TMessageType.CALL, self._seqid)
    args = listProvinceGaokaoStat_args()
    args.versionName = versionName
    args.provinceId = provinceId
    args.eduTypeWenli = eduTypeWenli
    args.year = year
    args.fromScore = fromScore
    args.toScore = toScore
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listProvinceGaokaoStat(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = listProvinceGaokaoStat_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listProvinceGaokaoStat failed: unknown result");

  def getProvinceScoreDist(self, versionName, provinceId, eduTypeWenli, year):
    """
    获取分数分布

    Parameters:
     - versionName
     - provinceId
     - eduTypeWenli
     - year
    """
    self.send_getProvinceScoreDist(versionName, provinceId, eduTypeWenli, year)
    return self.recv_getProvinceScoreDist()

  def send_getProvinceScoreDist(self, versionName, provinceId, eduTypeWenli, year):
    self._oprot.writeMessageBegin('getProvinceScoreDist', TMessageType.CALL, self._seqid)
    args = getProvinceScoreDist_args()
    args.versionName = versionName
    args.provinceId = provinceId
    args.eduTypeWenli = eduTypeWenli
    args.year = year
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getProvinceScoreDist(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getProvinceScoreDist_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getProvinceScoreDist failed: unknown result");

  def setGaokaoPeopleCount(self, versionName, pc):
    """
    设置省份人数

    Parameters:
     - versionName
     - pc
    """
    self.send_setGaokaoPeopleCount(versionName, pc)
    self.recv_setGaokaoPeopleCount()

  def send_setGaokaoPeopleCount(self, versionName, pc):
    self._oprot.writeMessageBegin('setGaokaoPeopleCount', TMessageType.CALL, self._seqid)
    args = setGaokaoPeopleCount_args()
    args.versionName = versionName
    args.pc = pc
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setGaokaoPeopleCount(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = setGaokaoPeopleCount_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.namedError is not None:
      raise result.namedError
    return

  def getGaokaoPeopleCount(self, versionName, provinceId, eduTypeWenli, year):
    """
    获取省份人数

    Parameters:
     - versionName
     - provinceId
     - eduTypeWenli
     - year
    """
    self.send_getGaokaoPeopleCount(versionName, provinceId, eduTypeWenli, year)
    return self.recv_getGaokaoPeopleCount()

  def send_getGaokaoPeopleCount(self, versionName, provinceId, eduTypeWenli, year):
    self._oprot.writeMessageBegin('getGaokaoPeopleCount', TMessageType.CALL, self._seqid)
    args = getGaokaoPeopleCount_args()
    args.versionName = versionName
    args.provinceId = provinceId
    args.eduTypeWenli = eduTypeWenli
    args.year = year
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getGaokaoPeopleCount(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getGaokaoPeopleCount_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getGaokaoPeopleCount failed: unknown result");

  def setSchScoreStat(self, versionName, stat):
    """
    设置学校分数统计

    Parameters:
     - versionName
     - stat
    """
    self.send_setSchScoreStat(versionName, stat)
    self.recv_setSchScoreStat()

  def send_setSchScoreStat(self, versionName, stat):
    self._oprot.writeMessageBegin('setSchScoreStat', TMessageType.CALL, self._seqid)
    args = setSchScoreStat_args()
    args.versionName = versionName
    args.stat = stat
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setSchScoreStat(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = setSchScoreStat_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.namedError is not None:
      raise result.namedError
    return

  def listSchScoreStat(self, versionName, eduTypeWenli, year, batch, fromProvinceId):
    """
    按文理科，年份，批次，考试省份 列出 学校分数统计

    Parameters:
     - versionName
     - eduTypeWenli
     - year
     - batch
     - fromProvinceId
    """
    self.send_listSchScoreStat(versionName, eduTypeWenli, year, batch, fromProvinceId)
    return self.recv_listSchScoreStat()

  def send_listSchScoreStat(self, versionName, eduTypeWenli, year, batch, fromProvinceId):
    self._oprot.writeMessageBegin('listSchScoreStat', TMessageType.CALL, self._seqid)
    args = listSchScoreStat_args()
    args.versionName = versionName
    args.eduTypeWenli = eduTypeWenli
    args.year = year
    args.batch = batch
    args.fromProvinceId = fromProvinceId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listSchScoreStat(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = listSchScoreStat_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listSchScoreStat failed: unknown result");

  def listSchScoreStatBySchId(self, versionName, schId):
    """
    Parameters:
     - versionName
     - schId
    """
    self.send_listSchScoreStatBySchId(versionName, schId)
    return self.recv_listSchScoreStatBySchId()

  def send_listSchScoreStatBySchId(self, versionName, schId):
    self._oprot.writeMessageBegin('listSchScoreStatBySchId', TMessageType.CALL, self._seqid)
    args = listSchScoreStatBySchId_args()
    args.versionName = versionName
    args.schId = schId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listSchScoreStatBySchId(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = listSchScoreStatBySchId_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listSchScoreStatBySchId failed: unknown result");

  def listAllSchScoreStat(self, versionName):
    """
    列出所有学校分数统计

    Parameters:
     - versionName
    """
    self.send_listAllSchScoreStat(versionName)
    return self.recv_listAllSchScoreStat()

  def send_listAllSchScoreStat(self, versionName):
    self._oprot.writeMessageBegin('listAllSchScoreStat', TMessageType.CALL, self._seqid)
    args = listAllSchScoreStat_args()
    args.versionName = versionName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listAllSchScoreStat(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = listAllSchScoreStat_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listAllSchScoreStat failed: unknown result");

  def setSchMajorScoreStat(self, versionName, stat):
    """
    设置学校专业分数统计

    Parameters:
     - versionName
     - stat
    """
    self.send_setSchMajorScoreStat(versionName, stat)
    self.recv_setSchMajorScoreStat()

  def send_setSchMajorScoreStat(self, versionName, stat):
    self._oprot.writeMessageBegin('setSchMajorScoreStat', TMessageType.CALL, self._seqid)
    args = setSchMajorScoreStat_args()
    args.versionName = versionName
    args.stat = stat
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setSchMajorScoreStat(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = setSchMajorScoreStat_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.namedError is not None:
      raise result.namedError
    return

  def listSchMajorScoreStat(self, versionName, eduTypeWenli, year, batch, fromProvinceId, schId):
    """
    按文理科，年份，批次，考试省份,学校 列出 学校专业分数

    Parameters:
     - versionName
     - eduTypeWenli
     - year
     - batch
     - fromProvinceId
     - schId
    """
    self.send_listSchMajorScoreStat(versionName, eduTypeWenli, year, batch, fromProvinceId, schId)
    return self.recv_listSchMajorScoreStat()

  def send_listSchMajorScoreStat(self, versionName, eduTypeWenli, year, batch, fromProvinceId, schId):
    self._oprot.writeMessageBegin('listSchMajorScoreStat', TMessageType.CALL, self._seqid)
    args = listSchMajorScoreStat_args()
    args.versionName = versionName
    args.eduTypeWenli = eduTypeWenli
    args.year = year
    args.batch = batch
    args.fromProvinceId = fromProvinceId
    args.schId = schId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listSchMajorScoreStat(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = listSchMajorScoreStat_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listSchMajorScoreStat failed: unknown result");

  def listSchMajorScoreStatListBySchMajor(self, versionName, schId, majorId):
    """
    按学校，专业列出分数

    Parameters:
     - versionName
     - schId
     - majorId
    """
    self.send_listSchMajorScoreStatListBySchMajor(versionName, schId, majorId)
    return self.recv_listSchMajorScoreStatListBySchMajor()

  def send_listSchMajorScoreStatListBySchMajor(self, versionName, schId, majorId):
    self._oprot.writeMessageBegin('listSchMajorScoreStatListBySchMajor', TMessageType.CALL, self._seqid)
    args = listSchMajorScoreStatListBySchMajor_args()
    args.versionName = versionName
    args.schId = schId
    args.majorId = majorId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listSchMajorScoreStatListBySchMajor(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = listSchMajorScoreStatListBySchMajor_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listSchMajorScoreStatListBySchMajor failed: unknown result");

  def listSchMajorScoreStatListBySch(self, versionName, schId):
    """
    按学校列出分数

    Parameters:
     - versionName
     - schId
    """
    self.send_listSchMajorScoreStatListBySch(versionName, schId)
    return self.recv_listSchMajorScoreStatListBySch()

  def send_listSchMajorScoreStatListBySch(self, versionName, schId):
    self._oprot.writeMessageBegin('listSchMajorScoreStatListBySch', TMessageType.CALL, self._seqid)
    args = listSchMajorScoreStatListBySch_args()
    args.versionName = versionName
    args.schId = schId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listSchMajorScoreStatListBySch(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = listSchMajorScoreStatListBySch_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listSchMajorScoreStatListBySch failed: unknown result");

  def getSchStat(self, versionName, eduTypeWenli, batch, fromProvinceId, schId, sizeRange):
    """
    按 文理 批次 省份(地区、全国) 学校id 列出学校不分年份的统计信息
    省份： id
    地区： region_XXX
    全国： -1

    Parameters:
     - versionName
     - eduTypeWenli
     - batch
     - fromProvinceId
     - schId
     - sizeRange
    """
    self.send_getSchStat(versionName, eduTypeWenli, batch, fromProvinceId, schId, sizeRange)
    return self.recv_getSchStat()

  def send_getSchStat(self, versionName, eduTypeWenli, batch, fromProvinceId, schId, sizeRange):
    self._oprot.writeMessageBegin('getSchStat', TMessageType.CALL, self._seqid)
    args = getSchStat_args()
    args.versionName = versionName
    args.eduTypeWenli = eduTypeWenli
    args.batch = batch
    args.fromProvinceId = fromProvinceId
    args.schId = schId
    args.sizeRange = sizeRange
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSchStat(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getSchStat_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSchStat failed: unknown result");

  def listSchStatBySch(self, versionName, SchId):
    """
    Parameters:
     - versionName
     - SchId
    """
    self.send_listSchStatBySch(versionName, SchId)
    return self.recv_listSchStatBySch()

  def send_listSchStatBySch(self, versionName, SchId):
    self._oprot.writeMessageBegin('listSchStatBySch', TMessageType.CALL, self._seqid)
    args = listSchStatBySch_args()
    args.versionName = versionName
    args.SchId = SchId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listSchStatBySch(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = listSchStatBySch_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listSchStatBySch failed: unknown result");

  def setSchStat(self, versionName, stat):
    """
    按 文理 批次 省份(地区、全国) 学校id 设置学校不分年份的统计信息
    省份： id
    地区： region_XXX
    全国： -1

    Parameters:
     - versionName
     - stat
    """
    self.send_setSchStat(versionName, stat)
    self.recv_setSchStat()

  def send_setSchStat(self, versionName, stat):
    self._oprot.writeMessageBegin('setSchStat', TMessageType.CALL, self._seqid)
    args = setSchStat_args()
    args.versionName = versionName
    args.stat = stat
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setSchStat(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = setSchStat_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.namedError is not None:
      raise result.namedError
    return

  def getSchCluster(self, versionName, eduTypeWenli, batch, fromProvinceId, schoolLocation, sizeRange):
    """
    按 文理 批次 生源地 学校地区 学校人数 列出学校的聚类统计

    Parameters:
     - versionName
     - eduTypeWenli
     - batch
     - fromProvinceId
     - schoolLocation
     - sizeRange
    """
    self.send_getSchCluster(versionName, eduTypeWenli, batch, fromProvinceId, schoolLocation, sizeRange)
    return self.recv_getSchCluster()

  def send_getSchCluster(self, versionName, eduTypeWenli, batch, fromProvinceId, schoolLocation, sizeRange):
    self._oprot.writeMessageBegin('getSchCluster', TMessageType.CALL, self._seqid)
    args = getSchCluster_args()
    args.versionName = versionName
    args.eduTypeWenli = eduTypeWenli
    args.batch = batch
    args.fromProvinceId = fromProvinceId
    args.schoolLocation = schoolLocation
    args.sizeRange = sizeRange
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSchCluster(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getSchCluster_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSchCluster failed: unknown result");

  def setSchCluster(self, versionName, cluster):
    """
    按 文理 批次 生源地 学校地区 学校人数 设置学校的聚类统计

    Parameters:
     - versionName
     - cluster
    """
    self.send_setSchCluster(versionName, cluster)
    self.recv_setSchCluster()

  def send_setSchCluster(self, versionName, cluster):
    self._oprot.writeMessageBegin('setSchCluster', TMessageType.CALL, self._seqid)
    args = setSchCluster_args()
    args.versionName = versionName
    args.cluster = cluster
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setSchCluster(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = setSchCluster_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.namedError is not None:
      raise result.namedError
    return

  def listSchClusterByFromProvince(self, versionName, fromProvinceId):
    """
    Parameters:
     - versionName
     - fromProvinceId
    """
    self.send_listSchClusterByFromProvince(versionName, fromProvinceId)
    return self.recv_listSchClusterByFromProvince()

  def send_listSchClusterByFromProvince(self, versionName, fromProvinceId):
    self._oprot.writeMessageBegin('listSchClusterByFromProvince', TMessageType.CALL, self._seqid)
    args = listSchClusterByFromProvince_args()
    args.versionName = versionName
    args.fromProvinceId = fromProvinceId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listSchClusterByFromProvince(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = listSchClusterByFromProvince_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listSchClusterByFromProvince failed: unknown result");

  def getProvinceScoreRankByScore(self, versionName, provinceId, year, eduTypeWenli, score):
    """
    按 省份 年份 文理 分数 获得排名


    Parameters:
     - versionName
     - provinceId
     - year
     - eduTypeWenli
     - score
    """
    self.send_getProvinceScoreRankByScore(versionName, provinceId, year, eduTypeWenli, score)
    return self.recv_getProvinceScoreRankByScore()

  def send_getProvinceScoreRankByScore(self, versionName, provinceId, year, eduTypeWenli, score):
    self._oprot.writeMessageBegin('getProvinceScoreRankByScore', TMessageType.CALL, self._seqid)
    args = getProvinceScoreRankByScore_args()
    args.versionName = versionName
    args.provinceId = provinceId
    args.year = year
    args.eduTypeWenli = eduTypeWenli
    args.score = score
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getProvinceScoreRankByScore(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getProvinceScoreRankByScore_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getProvinceScoreRankByScore failed: unknown result");

  def getProvinceScoreRankByRank(self, versionName, provinceId, year, eduTypeWenli, rank):
    """
    Parameters:
     - versionName
     - provinceId
     - year
     - eduTypeWenli
     - rank
    """
    self.send_getProvinceScoreRankByRank(versionName, provinceId, year, eduTypeWenli, rank)
    return self.recv_getProvinceScoreRankByRank()

  def send_getProvinceScoreRankByRank(self, versionName, provinceId, year, eduTypeWenli, rank):
    self._oprot.writeMessageBegin('getProvinceScoreRankByRank', TMessageType.CALL, self._seqid)
    args = getProvinceScoreRankByRank_args()
    args.versionName = versionName
    args.provinceId = provinceId
    args.year = year
    args.eduTypeWenli = eduTypeWenli
    args.rank = rank
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getProvinceScoreRankByRank(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getProvinceScoreRankByRank_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getProvinceScoreRankByRank failed: unknown result");

  def listProvinceScoreRank(self, versionName, provinceId, year, eduTypeWenli):
    """
    Parameters:
     - versionName
     - provinceId
     - year
     - eduTypeWenli
    """
    self.send_listProvinceScoreRank(versionName, provinceId, year, eduTypeWenli)
    return self.recv_listProvinceScoreRank()

  def send_listProvinceScoreRank(self, versionName, provinceId, year, eduTypeWenli):
    self._oprot.writeMessageBegin('listProvinceScoreRank', TMessageType.CALL, self._seqid)
    args = listProvinceScoreRank_args()
    args.versionName = versionName
    args.provinceId = provinceId
    args.year = year
    args.eduTypeWenli = eduTypeWenli
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listProvinceScoreRank(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = listProvinceScoreRank_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listProvinceScoreRank failed: unknown result");

  def setProvinceScoreRank(self, versionName, provinceScoreRank):
    """
    Parameters:
     - versionName
     - provinceScoreRank
    """
    self.send_setProvinceScoreRank(versionName, provinceScoreRank)
    self.recv_setProvinceScoreRank()

  def send_setProvinceScoreRank(self, versionName, provinceScoreRank):
    self._oprot.writeMessageBegin('setProvinceScoreRank', TMessageType.CALL, self._seqid)
    args = setProvinceScoreRank_args()
    args.versionName = versionName
    args.provinceScoreRank = provinceScoreRank
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setProvinceScoreRank(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = setProvinceScoreRank_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.namedError is not None:
      raise result.namedError
    return

  def getSchMeanAndStdev(self, versionName, fromProvinceId, schId, eduTypeWenli, batch):
    """
    按 生源地 学校ID 文理 批次 获得学校的统计信息

    Parameters:
     - versionName
     - fromProvinceId
     - schId
     - eduTypeWenli
     - batch
    """
    self.send_getSchMeanAndStdev(versionName, fromProvinceId, schId, eduTypeWenli, batch)
    return self.recv_getSchMeanAndStdev()

  def send_getSchMeanAndStdev(self, versionName, fromProvinceId, schId, eduTypeWenli, batch):
    self._oprot.writeMessageBegin('getSchMeanAndStdev', TMessageType.CALL, self._seqid)
    args = getSchMeanAndStdev_args()
    args.versionName = versionName
    args.fromProvinceId = fromProvinceId
    args.schId = schId
    args.eduTypeWenli = eduTypeWenli
    args.batch = batch
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSchMeanAndStdev(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getSchMeanAndStdev_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSchMeanAndStdev failed: unknown result");

  def listSchMeanAndStdev(self, versionName, fromProvinceId, eduTypeWenli, batch):
    """
    Parameters:
     - versionName
     - fromProvinceId
     - eduTypeWenli
     - batch
    """
    self.send_listSchMeanAndStdev(versionName, fromProvinceId, eduTypeWenli, batch)
    return self.recv_listSchMeanAndStdev()

  def send_listSchMeanAndStdev(self, versionName, fromProvinceId, eduTypeWenli, batch):
    self._oprot.writeMessageBegin('listSchMeanAndStdev', TMessageType.CALL, self._seqid)
    args = listSchMeanAndStdev_args()
    args.versionName = versionName
    args.fromProvinceId = fromProvinceId
    args.eduTypeWenli = eduTypeWenli
    args.batch = batch
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listSchMeanAndStdev(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = listSchMeanAndStdev_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listSchMeanAndStdev failed: unknown result");

  def setSchMeanAndStdev(self, versionName, stat):
    """
    Parameters:
     - versionName
     - stat
    """
    self.send_setSchMeanAndStdev(versionName, stat)
    self.recv_setSchMeanAndStdev()

  def send_setSchMeanAndStdev(self, versionName, stat):
    self._oprot.writeMessageBegin('setSchMeanAndStdev', TMessageType.CALL, self._seqid)
    args = setSchMeanAndStdev_args()
    args.versionName = versionName
    args.stat = stat
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setSchMeanAndStdev(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = setSchMeanAndStdev_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.namedError is not None:
      raise result.namedError
    return

  def getSameScoreStat(self, versionName, fromProvinceId, eduTypeWenli, batch, year, score, schId, majorId):
    """
    获取同分考试去向信息，包括学校、专业


    Parameters:
     - versionName
     - fromProvinceId
     - eduTypeWenli
     - batch
     - year
     - score
     - schId
     - majorId
    """
    self.send_getSameScoreStat(versionName, fromProvinceId, eduTypeWenli, batch, year, score, schId, majorId)
    return self.recv_getSameScoreStat()

  def send_getSameScoreStat(self, versionName, fromProvinceId, eduTypeWenli, batch, year, score, schId, majorId):
    self._oprot.writeMessageBegin('getSameScoreStat', TMessageType.CALL, self._seqid)
    args = getSameScoreStat_args()
    args.versionName = versionName
    args.fromProvinceId = fromProvinceId
    args.eduTypeWenli = eduTypeWenli
    args.batch = batch
    args.year = year
    args.score = score
    args.schId = schId
    args.majorId = majorId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSameScoreStat(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getSameScoreStat_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSameScoreStat failed: unknown result");

  def listSameScoreStat(self, versionName, fromProvinceId, eduTypeWenli, batch, year, score):
    """
    Parameters:
     - versionName
     - fromProvinceId
     - eduTypeWenli
     - batch
     - year
     - score
    """
    self.send_listSameScoreStat(versionName, fromProvinceId, eduTypeWenli, batch, year, score)
    return self.recv_listSameScoreStat()

  def send_listSameScoreStat(self, versionName, fromProvinceId, eduTypeWenli, batch, year, score):
    self._oprot.writeMessageBegin('listSameScoreStat', TMessageType.CALL, self._seqid)
    args = listSameScoreStat_args()
    args.versionName = versionName
    args.fromProvinceId = fromProvinceId
    args.eduTypeWenli = eduTypeWenli
    args.batch = batch
    args.year = year
    args.score = score
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listSameScoreStat(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = listSameScoreStat_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.namedError is not None:
      raise result.namedError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listSameScoreStat failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["setProvinceToudangScore"] = Processor.process_setProvinceToudangScore
    self._processMap["getProvinceToudangScore"] = Processor.process_getProvinceToudangScore
    self._processMap["listAllProvinceToudangScore"] = Processor.process_listAllProvinceToudangScore
    self._processMap["listProvinceToudangScore"] = Processor.process_listProvinceToudangScore
    self._processMap["listProvinceToudangScoreByProvince"] = Processor.process_listProvinceToudangScoreByProvince
    self._processMap["setProvinceGaokaoStat"] = Processor.process_setProvinceGaokaoStat
    self._processMap["listProvinceGaokaoStat"] = Processor.process_listProvinceGaokaoStat
    self._processMap["getProvinceScoreDist"] = Processor.process_getProvinceScoreDist
    self._processMap["setGaokaoPeopleCount"] = Processor.process_setGaokaoPeopleCount
    self._processMap["getGaokaoPeopleCount"] = Processor.process_getGaokaoPeopleCount
    self._processMap["setSchScoreStat"] = Processor.process_setSchScoreStat
    self._processMap["listSchScoreStat"] = Processor.process_listSchScoreStat
    self._processMap["listSchScoreStatBySchId"] = Processor.process_listSchScoreStatBySchId
    self._processMap["listAllSchScoreStat"] = Processor.process_listAllSchScoreStat
    self._processMap["setSchMajorScoreStat"] = Processor.process_setSchMajorScoreStat
    self._processMap["listSchMajorScoreStat"] = Processor.process_listSchMajorScoreStat
    self._processMap["listSchMajorScoreStatListBySchMajor"] = Processor.process_listSchMajorScoreStatListBySchMajor
    self._processMap["listSchMajorScoreStatListBySch"] = Processor.process_listSchMajorScoreStatListBySch
    self._processMap["getSchStat"] = Processor.process_getSchStat
    self._processMap["listSchStatBySch"] = Processor.process_listSchStatBySch
    self._processMap["setSchStat"] = Processor.process_setSchStat
    self._processMap["getSchCluster"] = Processor.process_getSchCluster
    self._processMap["setSchCluster"] = Processor.process_setSchCluster
    self._processMap["listSchClusterByFromProvince"] = Processor.process_listSchClusterByFromProvince
    self._processMap["getProvinceScoreRankByScore"] = Processor.process_getProvinceScoreRankByScore
    self._processMap["getProvinceScoreRankByRank"] = Processor.process_getProvinceScoreRankByRank
    self._processMap["listProvinceScoreRank"] = Processor.process_listProvinceScoreRank
    self._processMap["setProvinceScoreRank"] = Processor.process_setProvinceScoreRank
    self._processMap["getSchMeanAndStdev"] = Processor.process_getSchMeanAndStdev
    self._processMap["listSchMeanAndStdev"] = Processor.process_listSchMeanAndStdev
    self._processMap["setSchMeanAndStdev"] = Processor.process_setSchMeanAndStdev
    self._processMap["getSameScoreStat"] = Processor.process_getSameScoreStat
    self._processMap["listSameScoreStat"] = Processor.process_listSameScoreStat

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_setProvinceToudangScore(self, seqid, iprot, oprot):
    args = setProvinceToudangScore_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setProvinceToudangScore_result()
    try:
      self._handler.setProvinceToudangScore(args.versionName, args.pts)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("setProvinceToudangScore", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getProvinceToudangScore(self, seqid, iprot, oprot):
    args = getProvinceToudangScore_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getProvinceToudangScore_result()
    try:
      result.success = self._handler.getProvinceToudangScore(args.versionName, args.year, args.provinceId, args.eduTypeWenli, args.batch)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("getProvinceToudangScore", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listAllProvinceToudangScore(self, seqid, iprot, oprot):
    args = listAllProvinceToudangScore_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listAllProvinceToudangScore_result()
    try:
      result.success = self._handler.listAllProvinceToudangScore(args.versionName)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("listAllProvinceToudangScore", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listProvinceToudangScore(self, seqid, iprot, oprot):
    args = listProvinceToudangScore_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listProvinceToudangScore_result()
    try:
      result.success = self._handler.listProvinceToudangScore(args.versionName, args.year, args.eduTypeWenli, args.batch)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("listProvinceToudangScore", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listProvinceToudangScoreByProvince(self, seqid, iprot, oprot):
    args = listProvinceToudangScoreByProvince_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listProvinceToudangScoreByProvince_result()
    try:
      result.success = self._handler.listProvinceToudangScoreByProvince(args.versionName, args.year, args.provinceId, args.eduTypeWenli)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("listProvinceToudangScoreByProvince", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setProvinceGaokaoStat(self, seqid, iprot, oprot):
    args = setProvinceGaokaoStat_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setProvinceGaokaoStat_result()
    try:
      self._handler.setProvinceGaokaoStat(args.versionName, args.stat)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("setProvinceGaokaoStat", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listProvinceGaokaoStat(self, seqid, iprot, oprot):
    args = listProvinceGaokaoStat_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listProvinceGaokaoStat_result()
    try:
      result.success = self._handler.listProvinceGaokaoStat(args.versionName, args.provinceId, args.eduTypeWenli, args.year, args.fromScore, args.toScore)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("listProvinceGaokaoStat", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getProvinceScoreDist(self, seqid, iprot, oprot):
    args = getProvinceScoreDist_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getProvinceScoreDist_result()
    try:
      result.success = self._handler.getProvinceScoreDist(args.versionName, args.provinceId, args.eduTypeWenli, args.year)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("getProvinceScoreDist", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setGaokaoPeopleCount(self, seqid, iprot, oprot):
    args = setGaokaoPeopleCount_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setGaokaoPeopleCount_result()
    try:
      self._handler.setGaokaoPeopleCount(args.versionName, args.pc)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("setGaokaoPeopleCount", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getGaokaoPeopleCount(self, seqid, iprot, oprot):
    args = getGaokaoPeopleCount_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getGaokaoPeopleCount_result()
    try:
      result.success = self._handler.getGaokaoPeopleCount(args.versionName, args.provinceId, args.eduTypeWenli, args.year)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("getGaokaoPeopleCount", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setSchScoreStat(self, seqid, iprot, oprot):
    args = setSchScoreStat_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setSchScoreStat_result()
    try:
      self._handler.setSchScoreStat(args.versionName, args.stat)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("setSchScoreStat", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listSchScoreStat(self, seqid, iprot, oprot):
    args = listSchScoreStat_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listSchScoreStat_result()
    try:
      result.success = self._handler.listSchScoreStat(args.versionName, args.eduTypeWenli, args.year, args.batch, args.fromProvinceId)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("listSchScoreStat", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listSchScoreStatBySchId(self, seqid, iprot, oprot):
    args = listSchScoreStatBySchId_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listSchScoreStatBySchId_result()
    try:
      result.success = self._handler.listSchScoreStatBySchId(args.versionName, args.schId)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("listSchScoreStatBySchId", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listAllSchScoreStat(self, seqid, iprot, oprot):
    args = listAllSchScoreStat_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listAllSchScoreStat_result()
    try:
      result.success = self._handler.listAllSchScoreStat(args.versionName)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("listAllSchScoreStat", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setSchMajorScoreStat(self, seqid, iprot, oprot):
    args = setSchMajorScoreStat_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setSchMajorScoreStat_result()
    try:
      self._handler.setSchMajorScoreStat(args.versionName, args.stat)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("setSchMajorScoreStat", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listSchMajorScoreStat(self, seqid, iprot, oprot):
    args = listSchMajorScoreStat_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listSchMajorScoreStat_result()
    try:
      result.success = self._handler.listSchMajorScoreStat(args.versionName, args.eduTypeWenli, args.year, args.batch, args.fromProvinceId, args.schId)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("listSchMajorScoreStat", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listSchMajorScoreStatListBySchMajor(self, seqid, iprot, oprot):
    args = listSchMajorScoreStatListBySchMajor_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listSchMajorScoreStatListBySchMajor_result()
    try:
      result.success = self._handler.listSchMajorScoreStatListBySchMajor(args.versionName, args.schId, args.majorId)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("listSchMajorScoreStatListBySchMajor", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listSchMajorScoreStatListBySch(self, seqid, iprot, oprot):
    args = listSchMajorScoreStatListBySch_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listSchMajorScoreStatListBySch_result()
    try:
      result.success = self._handler.listSchMajorScoreStatListBySch(args.versionName, args.schId)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("listSchMajorScoreStatListBySch", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSchStat(self, seqid, iprot, oprot):
    args = getSchStat_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSchStat_result()
    try:
      result.success = self._handler.getSchStat(args.versionName, args.eduTypeWenli, args.batch, args.fromProvinceId, args.schId, args.sizeRange)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("getSchStat", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listSchStatBySch(self, seqid, iprot, oprot):
    args = listSchStatBySch_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listSchStatBySch_result()
    try:
      result.success = self._handler.listSchStatBySch(args.versionName, args.SchId)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("listSchStatBySch", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setSchStat(self, seqid, iprot, oprot):
    args = setSchStat_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setSchStat_result()
    try:
      self._handler.setSchStat(args.versionName, args.stat)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("setSchStat", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSchCluster(self, seqid, iprot, oprot):
    args = getSchCluster_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSchCluster_result()
    try:
      result.success = self._handler.getSchCluster(args.versionName, args.eduTypeWenli, args.batch, args.fromProvinceId, args.schoolLocation, args.sizeRange)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("getSchCluster", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setSchCluster(self, seqid, iprot, oprot):
    args = setSchCluster_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setSchCluster_result()
    try:
      self._handler.setSchCluster(args.versionName, args.cluster)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("setSchCluster", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listSchClusterByFromProvince(self, seqid, iprot, oprot):
    args = listSchClusterByFromProvince_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listSchClusterByFromProvince_result()
    try:
      result.success = self._handler.listSchClusterByFromProvince(args.versionName, args.fromProvinceId)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("listSchClusterByFromProvince", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getProvinceScoreRankByScore(self, seqid, iprot, oprot):
    args = getProvinceScoreRankByScore_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getProvinceScoreRankByScore_result()
    try:
      result.success = self._handler.getProvinceScoreRankByScore(args.versionName, args.provinceId, args.year, args.eduTypeWenli, args.score)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("getProvinceScoreRankByScore", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getProvinceScoreRankByRank(self, seqid, iprot, oprot):
    args = getProvinceScoreRankByRank_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getProvinceScoreRankByRank_result()
    try:
      result.success = self._handler.getProvinceScoreRankByRank(args.versionName, args.provinceId, args.year, args.eduTypeWenli, args.rank)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("getProvinceScoreRankByRank", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listProvinceScoreRank(self, seqid, iprot, oprot):
    args = listProvinceScoreRank_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listProvinceScoreRank_result()
    try:
      result.success = self._handler.listProvinceScoreRank(args.versionName, args.provinceId, args.year, args.eduTypeWenli)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("listProvinceScoreRank", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setProvinceScoreRank(self, seqid, iprot, oprot):
    args = setProvinceScoreRank_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setProvinceScoreRank_result()
    try:
      self._handler.setProvinceScoreRank(args.versionName, args.provinceScoreRank)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("setProvinceScoreRank", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSchMeanAndStdev(self, seqid, iprot, oprot):
    args = getSchMeanAndStdev_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSchMeanAndStdev_result()
    try:
      result.success = self._handler.getSchMeanAndStdev(args.versionName, args.fromProvinceId, args.schId, args.eduTypeWenli, args.batch)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("getSchMeanAndStdev", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listSchMeanAndStdev(self, seqid, iprot, oprot):
    args = listSchMeanAndStdev_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listSchMeanAndStdev_result()
    try:
      result.success = self._handler.listSchMeanAndStdev(args.versionName, args.fromProvinceId, args.eduTypeWenli, args.batch)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("listSchMeanAndStdev", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setSchMeanAndStdev(self, seqid, iprot, oprot):
    args = setSchMeanAndStdev_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setSchMeanAndStdev_result()
    try:
      self._handler.setSchMeanAndStdev(args.versionName, args.stat)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("setSchMeanAndStdev", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSameScoreStat(self, seqid, iprot, oprot):
    args = getSameScoreStat_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSameScoreStat_result()
    try:
      result.success = self._handler.getSameScoreStat(args.versionName, args.fromProvinceId, args.eduTypeWenli, args.batch, args.year, args.score, args.schId, args.majorId)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("getSameScoreStat", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listSameScoreStat(self, seqid, iprot, oprot):
    args = listSameScoreStat_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listSameScoreStat_result()
    try:
      result.success = self._handler.listSameScoreStat(args.versionName, args.fromProvinceId, args.eduTypeWenli, args.batch, args.year, args.score)
    except ipin.rpc.common.ttypes.NamedError, namedError:
      result.namedError = namedError
    oprot.writeMessageBegin("listSameScoreStat", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class setProvinceToudangScore_args(object):
  """
  Attributes:
   - versionName
   - pts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRUCT, 'pts', (ProvinceToudangScore, ProvinceToudangScore.thrift_spec), None, ), # 10
  )

  def __init__(self, versionName=None, pts=None,):
    self.versionName = versionName
    self.pts = pts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.pts = ProvinceToudangScore()
          self.pts.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setProvinceToudangScore_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.pts is not None:
      oprot.writeFieldBegin('pts', TType.STRUCT, 10)
      self.pts.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.pts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setProvinceToudangScore_result(object):
  """
  Attributes:
   - namedError
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, namedError=None,):
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setProvinceToudangScore_result')
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getProvinceToudangScore_args(object):
  """
  Attributes:
   - versionName
   - year
   - provinceId
   - eduTypeWenli
   - batch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.I16, 'year', None, None, ), # 10
    (11, TType.STRING, 'provinceId', None, None, ), # 11
    None, # 12
    (13, TType.I32, 'eduTypeWenli', None, None, ), # 13
    (14, TType.I32, 'batch', None, None, ), # 14
  )

  def __init__(self, versionName=None, year=None, provinceId=None, eduTypeWenli=None, batch=None,):
    self.versionName = versionName
    self.year = year
    self.provinceId = provinceId
    self.eduTypeWenli = eduTypeWenli
    self.batch = batch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I16:
          self.year = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.provinceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I32:
          self.eduTypeWenli = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I32:
          self.batch = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getProvinceToudangScore_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.year is not None:
      oprot.writeFieldBegin('year', TType.I16, 10)
      oprot.writeI16(self.year)
      oprot.writeFieldEnd()
    if self.provinceId is not None:
      oprot.writeFieldBegin('provinceId', TType.STRING, 11)
      oprot.writeString(self.provinceId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.eduTypeWenli is not None:
      oprot.writeFieldBegin('eduTypeWenli', TType.I32, 13)
      oprot.writeI32(self.eduTypeWenli)
      oprot.writeFieldEnd()
    if self.batch is not None:
      oprot.writeFieldBegin('batch', TType.I32, 14)
      oprot.writeI32(self.batch)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.year)
    value = (value * 31) ^ hash(self.provinceId)
    value = (value * 31) ^ hash(self.eduTypeWenli)
    value = (value * 31) ^ hash(self.batch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getProvinceToudangScore_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ProvinceToudangScore, ProvinceToudangScore.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ProvinceToudangScore()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getProvinceToudangScore_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listAllProvinceToudangScore_args(object):
  """
  Attributes:
   - versionName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
  )

  def __init__(self, versionName=None,):
    self.versionName = versionName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listAllProvinceToudangScore_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listAllProvinceToudangScore_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ProvinceToudangScore, ProvinceToudangScore.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype73, _size70) = iprot.readListBegin()
          for _i74 in xrange(_size70):
            _elem75 = ProvinceToudangScore()
            _elem75.read(iprot)
            self.success.append(_elem75)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listAllProvinceToudangScore_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter76 in self.success:
        iter76.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listProvinceToudangScore_args(object):
  """
  Attributes:
   - versionName
   - year
   - eduTypeWenli
   - batch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.I16, 'year', None, None, ), # 10
    None, # 11
    (12, TType.I32, 'eduTypeWenli', None, None, ), # 12
    (13, TType.I32, 'batch', None, None, ), # 13
  )

  def __init__(self, versionName=None, year=None, eduTypeWenli=None, batch=None,):
    self.versionName = versionName
    self.year = year
    self.eduTypeWenli = eduTypeWenli
    self.batch = batch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I16:
          self.year = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.eduTypeWenli = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I32:
          self.batch = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listProvinceToudangScore_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.year is not None:
      oprot.writeFieldBegin('year', TType.I16, 10)
      oprot.writeI16(self.year)
      oprot.writeFieldEnd()
    if self.eduTypeWenli is not None:
      oprot.writeFieldBegin('eduTypeWenli', TType.I32, 12)
      oprot.writeI32(self.eduTypeWenli)
      oprot.writeFieldEnd()
    if self.batch is not None:
      oprot.writeFieldBegin('batch', TType.I32, 13)
      oprot.writeI32(self.batch)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.year)
    value = (value * 31) ^ hash(self.eduTypeWenli)
    value = (value * 31) ^ hash(self.batch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listProvinceToudangScore_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ProvinceToudangScore, ProvinceToudangScore.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype80, _size77) = iprot.readListBegin()
          for _i81 in xrange(_size77):
            _elem82 = ProvinceToudangScore()
            _elem82.read(iprot)
            self.success.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listProvinceToudangScore_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter83 in self.success:
        iter83.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listProvinceToudangScoreByProvince_args(object):
  """
  Attributes:
   - versionName
   - year
   - provinceId
   - eduTypeWenli
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.I16, 'year', None, None, ), # 10
    (11, TType.STRING, 'provinceId', None, None, ), # 11
    None, # 12
    (13, TType.I32, 'eduTypeWenli', None, None, ), # 13
  )

  def __init__(self, versionName=None, year=None, provinceId=None, eduTypeWenli=None,):
    self.versionName = versionName
    self.year = year
    self.provinceId = provinceId
    self.eduTypeWenli = eduTypeWenli

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I16:
          self.year = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.provinceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I32:
          self.eduTypeWenli = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listProvinceToudangScoreByProvince_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.year is not None:
      oprot.writeFieldBegin('year', TType.I16, 10)
      oprot.writeI16(self.year)
      oprot.writeFieldEnd()
    if self.provinceId is not None:
      oprot.writeFieldBegin('provinceId', TType.STRING, 11)
      oprot.writeString(self.provinceId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.eduTypeWenli is not None:
      oprot.writeFieldBegin('eduTypeWenli', TType.I32, 13)
      oprot.writeI32(self.eduTypeWenli)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.year)
    value = (value * 31) ^ hash(self.provinceId)
    value = (value * 31) ^ hash(self.eduTypeWenli)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listProvinceToudangScoreByProvince_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ProvinceToudangScore, ProvinceToudangScore.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype87, _size84) = iprot.readListBegin()
          for _i88 in xrange(_size84):
            _elem89 = ProvinceToudangScore()
            _elem89.read(iprot)
            self.success.append(_elem89)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listProvinceToudangScoreByProvince_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter90 in self.success:
        iter90.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setProvinceGaokaoStat_args(object):
  """
  Attributes:
   - versionName
   - stat
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRUCT, 'stat', (ProvinceGaokaoStat, ProvinceGaokaoStat.thrift_spec), None, ), # 10
  )

  def __init__(self, versionName=None, stat=None,):
    self.versionName = versionName
    self.stat = stat

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.stat = ProvinceGaokaoStat()
          self.stat.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setProvinceGaokaoStat_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.stat is not None:
      oprot.writeFieldBegin('stat', TType.STRUCT, 10)
      self.stat.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.stat)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setProvinceGaokaoStat_result(object):
  """
  Attributes:
   - namedError
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, namedError=None,):
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setProvinceGaokaoStat_result')
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listProvinceGaokaoStat_args(object):
  """
  Attributes:
   - versionName
   - provinceId
   - eduTypeWenli
   - year
   - fromScore
   - toScore
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRING, 'provinceId', None, None, ), # 10
    (11, TType.I32, 'eduTypeWenli', None, None, ), # 11
    (12, TType.I16, 'year', None, None, ), # 12
    (13, TType.I16, 'fromScore', None, None, ), # 13
    (14, TType.I16, 'toScore', None, None, ), # 14
  )

  def __init__(self, versionName=None, provinceId=None, eduTypeWenli=None, year=None, fromScore=None, toScore=None,):
    self.versionName = versionName
    self.provinceId = provinceId
    self.eduTypeWenli = eduTypeWenli
    self.year = year
    self.fromScore = fromScore
    self.toScore = toScore

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.provinceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.eduTypeWenli = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I16:
          self.year = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I16:
          self.fromScore = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I16:
          self.toScore = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listProvinceGaokaoStat_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.provinceId is not None:
      oprot.writeFieldBegin('provinceId', TType.STRING, 10)
      oprot.writeString(self.provinceId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.eduTypeWenli is not None:
      oprot.writeFieldBegin('eduTypeWenli', TType.I32, 11)
      oprot.writeI32(self.eduTypeWenli)
      oprot.writeFieldEnd()
    if self.year is not None:
      oprot.writeFieldBegin('year', TType.I16, 12)
      oprot.writeI16(self.year)
      oprot.writeFieldEnd()
    if self.fromScore is not None:
      oprot.writeFieldBegin('fromScore', TType.I16, 13)
      oprot.writeI16(self.fromScore)
      oprot.writeFieldEnd()
    if self.toScore is not None:
      oprot.writeFieldBegin('toScore', TType.I16, 14)
      oprot.writeI16(self.toScore)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.provinceId)
    value = (value * 31) ^ hash(self.eduTypeWenli)
    value = (value * 31) ^ hash(self.year)
    value = (value * 31) ^ hash(self.fromScore)
    value = (value * 31) ^ hash(self.toScore)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listProvinceGaokaoStat_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ProvinceGaokaoStat, ProvinceGaokaoStat.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype94, _size91) = iprot.readListBegin()
          for _i95 in xrange(_size91):
            _elem96 = ProvinceGaokaoStat()
            _elem96.read(iprot)
            self.success.append(_elem96)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listProvinceGaokaoStat_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter97 in self.success:
        iter97.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getProvinceScoreDist_args(object):
  """
  Attributes:
   - versionName
   - provinceId
   - eduTypeWenli
   - year
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRING, 'provinceId', None, None, ), # 10
    (11, TType.I32, 'eduTypeWenli', None, None, ), # 11
    (12, TType.I16, 'year', None, None, ), # 12
  )

  def __init__(self, versionName=None, provinceId=None, eduTypeWenli=None, year=None,):
    self.versionName = versionName
    self.provinceId = provinceId
    self.eduTypeWenli = eduTypeWenli
    self.year = year

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.provinceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.eduTypeWenli = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I16:
          self.year = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getProvinceScoreDist_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.provinceId is not None:
      oprot.writeFieldBegin('provinceId', TType.STRING, 10)
      oprot.writeString(self.provinceId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.eduTypeWenli is not None:
      oprot.writeFieldBegin('eduTypeWenli', TType.I32, 11)
      oprot.writeI32(self.eduTypeWenli)
      oprot.writeFieldEnd()
    if self.year is not None:
      oprot.writeFieldBegin('year', TType.I16, 12)
      oprot.writeI16(self.year)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.provinceId)
    value = (value * 31) ^ hash(self.eduTypeWenli)
    value = (value * 31) ^ hash(self.year)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getProvinceScoreDist_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I16,None,TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype99, _vtype100, _size98 ) = iprot.readMapBegin()
          for _i102 in xrange(_size98):
            _key103 = iprot.readI16();
            _val104 = iprot.readI32();
            self.success[_key103] = _val104
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getProvinceScoreDist_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I16, TType.I32, len(self.success))
      for kiter105,viter106 in self.success.items():
        oprot.writeI16(kiter105)
        oprot.writeI32(viter106)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setGaokaoPeopleCount_args(object):
  """
  Attributes:
   - versionName
   - pc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRUCT, 'pc', (GaokaoPeopleCount, GaokaoPeopleCount.thrift_spec), None, ), # 10
  )

  def __init__(self, versionName=None, pc=None,):
    self.versionName = versionName
    self.pc = pc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.pc = GaokaoPeopleCount()
          self.pc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setGaokaoPeopleCount_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.pc is not None:
      oprot.writeFieldBegin('pc', TType.STRUCT, 10)
      self.pc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.pc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setGaokaoPeopleCount_result(object):
  """
  Attributes:
   - namedError
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, namedError=None,):
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setGaokaoPeopleCount_result')
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGaokaoPeopleCount_args(object):
  """
  Attributes:
   - versionName
   - provinceId
   - eduTypeWenli
   - year
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRING, 'provinceId', None, None, ), # 10
    (11, TType.I32, 'eduTypeWenli', None, None, ), # 11
    (12, TType.I16, 'year', None, None, ), # 12
  )

  def __init__(self, versionName=None, provinceId=None, eduTypeWenli=None, year=None,):
    self.versionName = versionName
    self.provinceId = provinceId
    self.eduTypeWenli = eduTypeWenli
    self.year = year

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.provinceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.eduTypeWenli = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I16:
          self.year = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGaokaoPeopleCount_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.provinceId is not None:
      oprot.writeFieldBegin('provinceId', TType.STRING, 10)
      oprot.writeString(self.provinceId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.eduTypeWenli is not None:
      oprot.writeFieldBegin('eduTypeWenli', TType.I32, 11)
      oprot.writeI32(self.eduTypeWenli)
      oprot.writeFieldEnd()
    if self.year is not None:
      oprot.writeFieldBegin('year', TType.I16, 12)
      oprot.writeI16(self.year)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.provinceId)
    value = (value * 31) ^ hash(self.eduTypeWenli)
    value = (value * 31) ^ hash(self.year)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGaokaoPeopleCount_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GaokaoPeopleCount, GaokaoPeopleCount.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GaokaoPeopleCount()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGaokaoPeopleCount_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setSchScoreStat_args(object):
  """
  Attributes:
   - versionName
   - stat
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRUCT, 'stat', (SchScoreStat, SchScoreStat.thrift_spec), None, ), # 10
  )

  def __init__(self, versionName=None, stat=None,):
    self.versionName = versionName
    self.stat = stat

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.stat = SchScoreStat()
          self.stat.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setSchScoreStat_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.stat is not None:
      oprot.writeFieldBegin('stat', TType.STRUCT, 10)
      self.stat.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.stat)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setSchScoreStat_result(object):
  """
  Attributes:
   - namedError
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, namedError=None,):
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setSchScoreStat_result')
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSchScoreStat_args(object):
  """
  Attributes:
   - versionName
   - eduTypeWenli
   - year
   - batch
   - fromProvinceId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.I32, 'eduTypeWenli', None, None, ), # 10
    (11, TType.I16, 'year', None, None, ), # 11
    (12, TType.I32, 'batch', None, None, ), # 12
    (13, TType.STRING, 'fromProvinceId', None, None, ), # 13
  )

  def __init__(self, versionName=None, eduTypeWenli=None, year=None, batch=None, fromProvinceId=None,):
    self.versionName = versionName
    self.eduTypeWenli = eduTypeWenli
    self.year = year
    self.batch = batch
    self.fromProvinceId = fromProvinceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.eduTypeWenli = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I16:
          self.year = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.batch = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.fromProvinceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSchScoreStat_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.eduTypeWenli is not None:
      oprot.writeFieldBegin('eduTypeWenli', TType.I32, 10)
      oprot.writeI32(self.eduTypeWenli)
      oprot.writeFieldEnd()
    if self.year is not None:
      oprot.writeFieldBegin('year', TType.I16, 11)
      oprot.writeI16(self.year)
      oprot.writeFieldEnd()
    if self.batch is not None:
      oprot.writeFieldBegin('batch', TType.I32, 12)
      oprot.writeI32(self.batch)
      oprot.writeFieldEnd()
    if self.fromProvinceId is not None:
      oprot.writeFieldBegin('fromProvinceId', TType.STRING, 13)
      oprot.writeString(self.fromProvinceId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.eduTypeWenli)
    value = (value * 31) ^ hash(self.year)
    value = (value * 31) ^ hash(self.batch)
    value = (value * 31) ^ hash(self.fromProvinceId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSchScoreStat_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(SchScoreStat, SchScoreStat.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype110, _size107) = iprot.readListBegin()
          for _i111 in xrange(_size107):
            _elem112 = SchScoreStat()
            _elem112.read(iprot)
            self.success.append(_elem112)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSchScoreStat_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter113 in self.success:
        iter113.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSchScoreStatBySchId_args(object):
  """
  Attributes:
   - versionName
   - schId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRING, 'schId', None, None, ), # 10
  )

  def __init__(self, versionName=None, schId=None,):
    self.versionName = versionName
    self.schId = schId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.schId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSchScoreStatBySchId_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.schId is not None:
      oprot.writeFieldBegin('schId', TType.STRING, 10)
      oprot.writeString(self.schId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.schId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSchScoreStatBySchId_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(SchScoreStat, SchScoreStat.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype117, _size114) = iprot.readListBegin()
          for _i118 in xrange(_size114):
            _elem119 = SchScoreStat()
            _elem119.read(iprot)
            self.success.append(_elem119)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSchScoreStatBySchId_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter120 in self.success:
        iter120.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listAllSchScoreStat_args(object):
  """
  Attributes:
   - versionName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
  )

  def __init__(self, versionName=None,):
    self.versionName = versionName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listAllSchScoreStat_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listAllSchScoreStat_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(SchScoreStat, SchScoreStat.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype124, _size121) = iprot.readListBegin()
          for _i125 in xrange(_size121):
            _elem126 = SchScoreStat()
            _elem126.read(iprot)
            self.success.append(_elem126)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listAllSchScoreStat_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter127 in self.success:
        iter127.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setSchMajorScoreStat_args(object):
  """
  Attributes:
   - versionName
   - stat
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRUCT, 'stat', (SchMajorScoreStat, SchMajorScoreStat.thrift_spec), None, ), # 10
  )

  def __init__(self, versionName=None, stat=None,):
    self.versionName = versionName
    self.stat = stat

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.stat = SchMajorScoreStat()
          self.stat.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setSchMajorScoreStat_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.stat is not None:
      oprot.writeFieldBegin('stat', TType.STRUCT, 10)
      self.stat.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.stat)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setSchMajorScoreStat_result(object):
  """
  Attributes:
   - namedError
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, namedError=None,):
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setSchMajorScoreStat_result')
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSchMajorScoreStat_args(object):
  """
  Attributes:
   - versionName
   - eduTypeWenli
   - year
   - batch
   - fromProvinceId
   - schId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.I32, 'eduTypeWenli', None, None, ), # 10
    (11, TType.I16, 'year', None, None, ), # 11
    (12, TType.I32, 'batch', None, None, ), # 12
    (13, TType.STRING, 'fromProvinceId', None, None, ), # 13
    (14, TType.STRING, 'schId', None, None, ), # 14
  )

  def __init__(self, versionName=None, eduTypeWenli=None, year=None, batch=None, fromProvinceId=None, schId=None,):
    self.versionName = versionName
    self.eduTypeWenli = eduTypeWenli
    self.year = year
    self.batch = batch
    self.fromProvinceId = fromProvinceId
    self.schId = schId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.eduTypeWenli = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I16:
          self.year = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.batch = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.fromProvinceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.schId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSchMajorScoreStat_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.eduTypeWenli is not None:
      oprot.writeFieldBegin('eduTypeWenli', TType.I32, 10)
      oprot.writeI32(self.eduTypeWenli)
      oprot.writeFieldEnd()
    if self.year is not None:
      oprot.writeFieldBegin('year', TType.I16, 11)
      oprot.writeI16(self.year)
      oprot.writeFieldEnd()
    if self.batch is not None:
      oprot.writeFieldBegin('batch', TType.I32, 12)
      oprot.writeI32(self.batch)
      oprot.writeFieldEnd()
    if self.fromProvinceId is not None:
      oprot.writeFieldBegin('fromProvinceId', TType.STRING, 13)
      oprot.writeString(self.fromProvinceId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.schId is not None:
      oprot.writeFieldBegin('schId', TType.STRING, 14)
      oprot.writeString(self.schId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.eduTypeWenli)
    value = (value * 31) ^ hash(self.year)
    value = (value * 31) ^ hash(self.batch)
    value = (value * 31) ^ hash(self.fromProvinceId)
    value = (value * 31) ^ hash(self.schId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSchMajorScoreStat_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(SchMajorScoreStat, SchMajorScoreStat.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype131, _size128) = iprot.readListBegin()
          for _i132 in xrange(_size128):
            _elem133 = SchMajorScoreStat()
            _elem133.read(iprot)
            self.success.append(_elem133)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSchMajorScoreStat_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter134 in self.success:
        iter134.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSchMajorScoreStatListBySchMajor_args(object):
  """
  Attributes:
   - versionName
   - schId
   - majorId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRING, 'schId', None, None, ), # 10
    (11, TType.STRING, 'majorId', None, None, ), # 11
  )

  def __init__(self, versionName=None, schId=None, majorId=None,):
    self.versionName = versionName
    self.schId = schId
    self.majorId = majorId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.schId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.majorId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSchMajorScoreStatListBySchMajor_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.schId is not None:
      oprot.writeFieldBegin('schId', TType.STRING, 10)
      oprot.writeString(self.schId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.majorId is not None:
      oprot.writeFieldBegin('majorId', TType.STRING, 11)
      oprot.writeString(self.majorId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.schId)
    value = (value * 31) ^ hash(self.majorId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSchMajorScoreStatListBySchMajor_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(SchMajorScoreStat, SchMajorScoreStat.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype138, _size135) = iprot.readListBegin()
          for _i139 in xrange(_size135):
            _elem140 = SchMajorScoreStat()
            _elem140.read(iprot)
            self.success.append(_elem140)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSchMajorScoreStatListBySchMajor_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter141 in self.success:
        iter141.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSchMajorScoreStatListBySch_args(object):
  """
  Attributes:
   - versionName
   - schId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRING, 'schId', None, None, ), # 10
  )

  def __init__(self, versionName=None, schId=None,):
    self.versionName = versionName
    self.schId = schId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.schId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSchMajorScoreStatListBySch_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.schId is not None:
      oprot.writeFieldBegin('schId', TType.STRING, 10)
      oprot.writeString(self.schId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.schId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSchMajorScoreStatListBySch_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(SchMajorScoreStat, SchMajorScoreStat.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype145, _size142) = iprot.readListBegin()
          for _i146 in xrange(_size142):
            _elem147 = SchMajorScoreStat()
            _elem147.read(iprot)
            self.success.append(_elem147)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSchMajorScoreStatListBySch_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter148 in self.success:
        iter148.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSchStat_args(object):
  """
  Attributes:
   - versionName
   - eduTypeWenli
   - batch
   - fromProvinceId
   - schId
   - sizeRange
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.I32, 'eduTypeWenli', None, None, ), # 10
    (11, TType.I32, 'batch', None, None, ), # 11
    (12, TType.STRING, 'fromProvinceId', None, None, ), # 12
    (13, TType.STRING, 'schId', None, None, ), # 13
    (14, TType.STRING, 'sizeRange', None, None, ), # 14
  )

  def __init__(self, versionName=None, eduTypeWenli=None, batch=None, fromProvinceId=None, schId=None, sizeRange=None,):
    self.versionName = versionName
    self.eduTypeWenli = eduTypeWenli
    self.batch = batch
    self.fromProvinceId = fromProvinceId
    self.schId = schId
    self.sizeRange = sizeRange

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.eduTypeWenli = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.batch = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.fromProvinceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.schId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.sizeRange = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSchStat_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.eduTypeWenli is not None:
      oprot.writeFieldBegin('eduTypeWenli', TType.I32, 10)
      oprot.writeI32(self.eduTypeWenli)
      oprot.writeFieldEnd()
    if self.batch is not None:
      oprot.writeFieldBegin('batch', TType.I32, 11)
      oprot.writeI32(self.batch)
      oprot.writeFieldEnd()
    if self.fromProvinceId is not None:
      oprot.writeFieldBegin('fromProvinceId', TType.STRING, 12)
      oprot.writeString(self.fromProvinceId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.schId is not None:
      oprot.writeFieldBegin('schId', TType.STRING, 13)
      oprot.writeString(self.schId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.sizeRange is not None:
      oprot.writeFieldBegin('sizeRange', TType.STRING, 14)
      oprot.writeString(self.sizeRange.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.eduTypeWenli)
    value = (value * 31) ^ hash(self.batch)
    value = (value * 31) ^ hash(self.fromProvinceId)
    value = (value * 31) ^ hash(self.schId)
    value = (value * 31) ^ hash(self.sizeRange)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSchStat_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SchStat, SchStat.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SchStat()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSchStat_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSchStatBySch_args(object):
  """
  Attributes:
   - versionName
   - SchId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRING, 'SchId', None, None, ), # 10
  )

  def __init__(self, versionName=None, SchId=None,):
    self.versionName = versionName
    self.SchId = SchId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.SchId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSchStatBySch_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.SchId is not None:
      oprot.writeFieldBegin('SchId', TType.STRING, 10)
      oprot.writeString(self.SchId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.SchId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSchStatBySch_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(SchStat, SchStat.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype152, _size149) = iprot.readListBegin()
          for _i153 in xrange(_size149):
            _elem154 = SchStat()
            _elem154.read(iprot)
            self.success.append(_elem154)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSchStatBySch_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter155 in self.success:
        iter155.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setSchStat_args(object):
  """
  Attributes:
   - versionName
   - stat
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRUCT, 'stat', (SchStat, SchStat.thrift_spec), None, ), # 10
  )

  def __init__(self, versionName=None, stat=None,):
    self.versionName = versionName
    self.stat = stat

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.stat = SchStat()
          self.stat.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setSchStat_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.stat is not None:
      oprot.writeFieldBegin('stat', TType.STRUCT, 10)
      self.stat.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.stat)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setSchStat_result(object):
  """
  Attributes:
   - namedError
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, namedError=None,):
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setSchStat_result')
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSchCluster_args(object):
  """
  Attributes:
   - versionName
   - eduTypeWenli
   - batch
   - fromProvinceId
   - schoolLocation
   - sizeRange
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.I32, 'eduTypeWenli', None, None, ), # 10
    (11, TType.I32, 'batch', None, None, ), # 11
    (12, TType.STRING, 'fromProvinceId', None, None, ), # 12
    (13, TType.STRING, 'schoolLocation', None, None, ), # 13
    (14, TType.STRING, 'sizeRange', None, None, ), # 14
  )

  def __init__(self, versionName=None, eduTypeWenli=None, batch=None, fromProvinceId=None, schoolLocation=None, sizeRange=None,):
    self.versionName = versionName
    self.eduTypeWenli = eduTypeWenli
    self.batch = batch
    self.fromProvinceId = fromProvinceId
    self.schoolLocation = schoolLocation
    self.sizeRange = sizeRange

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.eduTypeWenli = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.batch = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.fromProvinceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.schoolLocation = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.sizeRange = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSchCluster_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.eduTypeWenli is not None:
      oprot.writeFieldBegin('eduTypeWenli', TType.I32, 10)
      oprot.writeI32(self.eduTypeWenli)
      oprot.writeFieldEnd()
    if self.batch is not None:
      oprot.writeFieldBegin('batch', TType.I32, 11)
      oprot.writeI32(self.batch)
      oprot.writeFieldEnd()
    if self.fromProvinceId is not None:
      oprot.writeFieldBegin('fromProvinceId', TType.STRING, 12)
      oprot.writeString(self.fromProvinceId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.schoolLocation is not None:
      oprot.writeFieldBegin('schoolLocation', TType.STRING, 13)
      oprot.writeString(self.schoolLocation.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.sizeRange is not None:
      oprot.writeFieldBegin('sizeRange', TType.STRING, 14)
      oprot.writeString(self.sizeRange.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.eduTypeWenli)
    value = (value * 31) ^ hash(self.batch)
    value = (value * 31) ^ hash(self.fromProvinceId)
    value = (value * 31) ^ hash(self.schoolLocation)
    value = (value * 31) ^ hash(self.sizeRange)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSchCluster_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SchCluster, SchCluster.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SchCluster()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSchCluster_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setSchCluster_args(object):
  """
  Attributes:
   - versionName
   - cluster
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRUCT, 'cluster', (SchCluster, SchCluster.thrift_spec), None, ), # 10
  )

  def __init__(self, versionName=None, cluster=None,):
    self.versionName = versionName
    self.cluster = cluster

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.cluster = SchCluster()
          self.cluster.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setSchCluster_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.cluster is not None:
      oprot.writeFieldBegin('cluster', TType.STRUCT, 10)
      self.cluster.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.cluster)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setSchCluster_result(object):
  """
  Attributes:
   - namedError
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, namedError=None,):
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setSchCluster_result')
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSchClusterByFromProvince_args(object):
  """
  Attributes:
   - versionName
   - fromProvinceId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRING, 'fromProvinceId', None, None, ), # 10
  )

  def __init__(self, versionName=None, fromProvinceId=None,):
    self.versionName = versionName
    self.fromProvinceId = fromProvinceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.fromProvinceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSchClusterByFromProvince_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.fromProvinceId is not None:
      oprot.writeFieldBegin('fromProvinceId', TType.STRING, 10)
      oprot.writeString(self.fromProvinceId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.fromProvinceId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSchClusterByFromProvince_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(SchCluster, SchCluster.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype159, _size156) = iprot.readListBegin()
          for _i160 in xrange(_size156):
            _elem161 = SchCluster()
            _elem161.read(iprot)
            self.success.append(_elem161)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSchClusterByFromProvince_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter162 in self.success:
        iter162.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getProvinceScoreRankByScore_args(object):
  """
  Attributes:
   - versionName
   - provinceId
   - year
   - eduTypeWenli
   - score
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRING, 'provinceId', None, None, ), # 10
    (11, TType.I16, 'year', None, None, ), # 11
    (12, TType.I32, 'eduTypeWenli', None, None, ), # 12
    (13, TType.I16, 'score', None, None, ), # 13
  )

  def __init__(self, versionName=None, provinceId=None, year=None, eduTypeWenli=None, score=None,):
    self.versionName = versionName
    self.provinceId = provinceId
    self.year = year
    self.eduTypeWenli = eduTypeWenli
    self.score = score

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.provinceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I16:
          self.year = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.eduTypeWenli = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I16:
          self.score = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getProvinceScoreRankByScore_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.provinceId is not None:
      oprot.writeFieldBegin('provinceId', TType.STRING, 10)
      oprot.writeString(self.provinceId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.year is not None:
      oprot.writeFieldBegin('year', TType.I16, 11)
      oprot.writeI16(self.year)
      oprot.writeFieldEnd()
    if self.eduTypeWenli is not None:
      oprot.writeFieldBegin('eduTypeWenli', TType.I32, 12)
      oprot.writeI32(self.eduTypeWenli)
      oprot.writeFieldEnd()
    if self.score is not None:
      oprot.writeFieldBegin('score', TType.I16, 13)
      oprot.writeI16(self.score)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.provinceId)
    value = (value * 31) ^ hash(self.year)
    value = (value * 31) ^ hash(self.eduTypeWenli)
    value = (value * 31) ^ hash(self.score)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getProvinceScoreRankByScore_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ProvinceScoreRank, ProvinceScoreRank.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ProvinceScoreRank()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getProvinceScoreRankByScore_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getProvinceScoreRankByRank_args(object):
  """
  Attributes:
   - versionName
   - provinceId
   - year
   - eduTypeWenli
   - rank
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRING, 'provinceId', None, None, ), # 10
    (11, TType.I16, 'year', None, None, ), # 11
    (12, TType.I32, 'eduTypeWenli', None, None, ), # 12
    (13, TType.I32, 'rank', None, None, ), # 13
  )

  def __init__(self, versionName=None, provinceId=None, year=None, eduTypeWenli=None, rank=None,):
    self.versionName = versionName
    self.provinceId = provinceId
    self.year = year
    self.eduTypeWenli = eduTypeWenli
    self.rank = rank

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.provinceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I16:
          self.year = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.eduTypeWenli = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I32:
          self.rank = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getProvinceScoreRankByRank_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.provinceId is not None:
      oprot.writeFieldBegin('provinceId', TType.STRING, 10)
      oprot.writeString(self.provinceId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.year is not None:
      oprot.writeFieldBegin('year', TType.I16, 11)
      oprot.writeI16(self.year)
      oprot.writeFieldEnd()
    if self.eduTypeWenli is not None:
      oprot.writeFieldBegin('eduTypeWenli', TType.I32, 12)
      oprot.writeI32(self.eduTypeWenli)
      oprot.writeFieldEnd()
    if self.rank is not None:
      oprot.writeFieldBegin('rank', TType.I32, 13)
      oprot.writeI32(self.rank)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.provinceId)
    value = (value * 31) ^ hash(self.year)
    value = (value * 31) ^ hash(self.eduTypeWenli)
    value = (value * 31) ^ hash(self.rank)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getProvinceScoreRankByRank_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ProvinceScoreRank, ProvinceScoreRank.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ProvinceScoreRank()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getProvinceScoreRankByRank_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listProvinceScoreRank_args(object):
  """
  Attributes:
   - versionName
   - provinceId
   - year
   - eduTypeWenli
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRING, 'provinceId', None, None, ), # 10
    (11, TType.I16, 'year', None, None, ), # 11
    (12, TType.I32, 'eduTypeWenli', None, None, ), # 12
  )

  def __init__(self, versionName=None, provinceId=None, year=None, eduTypeWenli=None,):
    self.versionName = versionName
    self.provinceId = provinceId
    self.year = year
    self.eduTypeWenli = eduTypeWenli

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.provinceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I16:
          self.year = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.eduTypeWenli = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listProvinceScoreRank_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.provinceId is not None:
      oprot.writeFieldBegin('provinceId', TType.STRING, 10)
      oprot.writeString(self.provinceId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.year is not None:
      oprot.writeFieldBegin('year', TType.I16, 11)
      oprot.writeI16(self.year)
      oprot.writeFieldEnd()
    if self.eduTypeWenli is not None:
      oprot.writeFieldBegin('eduTypeWenli', TType.I32, 12)
      oprot.writeI32(self.eduTypeWenli)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.provinceId)
    value = (value * 31) ^ hash(self.year)
    value = (value * 31) ^ hash(self.eduTypeWenli)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listProvinceScoreRank_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ProvinceScoreRank, ProvinceScoreRank.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype166, _size163) = iprot.readListBegin()
          for _i167 in xrange(_size163):
            _elem168 = ProvinceScoreRank()
            _elem168.read(iprot)
            self.success.append(_elem168)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listProvinceScoreRank_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter169 in self.success:
        iter169.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setProvinceScoreRank_args(object):
  """
  Attributes:
   - versionName
   - provinceScoreRank
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRUCT, 'provinceScoreRank', (ProvinceScoreRank, ProvinceScoreRank.thrift_spec), None, ), # 10
  )

  def __init__(self, versionName=None, provinceScoreRank=None,):
    self.versionName = versionName
    self.provinceScoreRank = provinceScoreRank

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.provinceScoreRank = ProvinceScoreRank()
          self.provinceScoreRank.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setProvinceScoreRank_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.provinceScoreRank is not None:
      oprot.writeFieldBegin('provinceScoreRank', TType.STRUCT, 10)
      self.provinceScoreRank.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.provinceScoreRank)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setProvinceScoreRank_result(object):
  """
  Attributes:
   - namedError
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, namedError=None,):
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setProvinceScoreRank_result')
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSchMeanAndStdev_args(object):
  """
  Attributes:
   - versionName
   - fromProvinceId
   - schId
   - eduTypeWenli
   - batch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRING, 'fromProvinceId', None, None, ), # 10
    (11, TType.STRING, 'schId', None, None, ), # 11
    (12, TType.I32, 'eduTypeWenli', None, None, ), # 12
    (13, TType.I32, 'batch', None, None, ), # 13
  )

  def __init__(self, versionName=None, fromProvinceId=None, schId=None, eduTypeWenli=None, batch=None,):
    self.versionName = versionName
    self.fromProvinceId = fromProvinceId
    self.schId = schId
    self.eduTypeWenli = eduTypeWenli
    self.batch = batch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.fromProvinceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.schId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.eduTypeWenli = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I32:
          self.batch = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSchMeanAndStdev_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.fromProvinceId is not None:
      oprot.writeFieldBegin('fromProvinceId', TType.STRING, 10)
      oprot.writeString(self.fromProvinceId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.schId is not None:
      oprot.writeFieldBegin('schId', TType.STRING, 11)
      oprot.writeString(self.schId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.eduTypeWenli is not None:
      oprot.writeFieldBegin('eduTypeWenli', TType.I32, 12)
      oprot.writeI32(self.eduTypeWenli)
      oprot.writeFieldEnd()
    if self.batch is not None:
      oprot.writeFieldBegin('batch', TType.I32, 13)
      oprot.writeI32(self.batch)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.fromProvinceId)
    value = (value * 31) ^ hash(self.schId)
    value = (value * 31) ^ hash(self.eduTypeWenli)
    value = (value * 31) ^ hash(self.batch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSchMeanAndStdev_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SchMeanAndStdev, SchMeanAndStdev.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SchMeanAndStdev()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSchMeanAndStdev_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSchMeanAndStdev_args(object):
  """
  Attributes:
   - versionName
   - fromProvinceId
   - eduTypeWenli
   - batch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRING, 'fromProvinceId', None, None, ), # 10
    (11, TType.I32, 'eduTypeWenli', None, None, ), # 11
    (12, TType.I32, 'batch', None, None, ), # 12
  )

  def __init__(self, versionName=None, fromProvinceId=None, eduTypeWenli=None, batch=None,):
    self.versionName = versionName
    self.fromProvinceId = fromProvinceId
    self.eduTypeWenli = eduTypeWenli
    self.batch = batch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.fromProvinceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.eduTypeWenli = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.batch = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSchMeanAndStdev_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.fromProvinceId is not None:
      oprot.writeFieldBegin('fromProvinceId', TType.STRING, 10)
      oprot.writeString(self.fromProvinceId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.eduTypeWenli is not None:
      oprot.writeFieldBegin('eduTypeWenli', TType.I32, 11)
      oprot.writeI32(self.eduTypeWenli)
      oprot.writeFieldEnd()
    if self.batch is not None:
      oprot.writeFieldBegin('batch', TType.I32, 12)
      oprot.writeI32(self.batch)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.fromProvinceId)
    value = (value * 31) ^ hash(self.eduTypeWenli)
    value = (value * 31) ^ hash(self.batch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSchMeanAndStdev_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(SchMeanAndStdev, SchMeanAndStdev.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype173, _size170) = iprot.readListBegin()
          for _i174 in xrange(_size170):
            _elem175 = SchMeanAndStdev()
            _elem175.read(iprot)
            self.success.append(_elem175)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSchMeanAndStdev_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter176 in self.success:
        iter176.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setSchMeanAndStdev_args(object):
  """
  Attributes:
   - versionName
   - stat
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRUCT, 'stat', (SchMeanAndStdev, SchMeanAndStdev.thrift_spec), None, ), # 10
  )

  def __init__(self, versionName=None, stat=None,):
    self.versionName = versionName
    self.stat = stat

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.stat = SchMeanAndStdev()
          self.stat.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setSchMeanAndStdev_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.stat is not None:
      oprot.writeFieldBegin('stat', TType.STRUCT, 10)
      self.stat.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.stat)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setSchMeanAndStdev_result(object):
  """
  Attributes:
   - namedError
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, namedError=None,):
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setSchMeanAndStdev_result')
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSameScoreStat_args(object):
  """
  Attributes:
   - versionName
   - fromProvinceId
   - eduTypeWenli
   - batch
   - year
   - score
   - schId
   - majorId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRING, 'fromProvinceId', None, None, ), # 10
    (11, TType.I32, 'eduTypeWenli', None, None, ), # 11
    (12, TType.I32, 'batch', None, None, ), # 12
    (13, TType.I16, 'year', None, None, ), # 13
    (14, TType.I16, 'score', None, None, ), # 14
    (15, TType.STRING, 'schId', None, None, ), # 15
    (16, TType.STRING, 'majorId', None, None, ), # 16
  )

  def __init__(self, versionName=None, fromProvinceId=None, eduTypeWenli=None, batch=None, year=None, score=None, schId=None, majorId=None,):
    self.versionName = versionName
    self.fromProvinceId = fromProvinceId
    self.eduTypeWenli = eduTypeWenli
    self.batch = batch
    self.year = year
    self.score = score
    self.schId = schId
    self.majorId = majorId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.fromProvinceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.eduTypeWenli = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.batch = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I16:
          self.year = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I16:
          self.score = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRING:
          self.schId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRING:
          self.majorId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSameScoreStat_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.fromProvinceId is not None:
      oprot.writeFieldBegin('fromProvinceId', TType.STRING, 10)
      oprot.writeString(self.fromProvinceId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.eduTypeWenli is not None:
      oprot.writeFieldBegin('eduTypeWenli', TType.I32, 11)
      oprot.writeI32(self.eduTypeWenli)
      oprot.writeFieldEnd()
    if self.batch is not None:
      oprot.writeFieldBegin('batch', TType.I32, 12)
      oprot.writeI32(self.batch)
      oprot.writeFieldEnd()
    if self.year is not None:
      oprot.writeFieldBegin('year', TType.I16, 13)
      oprot.writeI16(self.year)
      oprot.writeFieldEnd()
    if self.score is not None:
      oprot.writeFieldBegin('score', TType.I16, 14)
      oprot.writeI16(self.score)
      oprot.writeFieldEnd()
    if self.schId is not None:
      oprot.writeFieldBegin('schId', TType.STRING, 15)
      oprot.writeString(self.schId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.majorId is not None:
      oprot.writeFieldBegin('majorId', TType.STRING, 16)
      oprot.writeString(self.majorId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.fromProvinceId)
    value = (value * 31) ^ hash(self.eduTypeWenli)
    value = (value * 31) ^ hash(self.batch)
    value = (value * 31) ^ hash(self.year)
    value = (value * 31) ^ hash(self.score)
    value = (value * 31) ^ hash(self.schId)
    value = (value * 31) ^ hash(self.majorId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSameScoreStat_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SameScoreStat, SameScoreStat.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SameScoreStat()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSameScoreStat_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSameScoreStat_args(object):
  """
  Attributes:
   - versionName
   - fromProvinceId
   - eduTypeWenli
   - batch
   - year
   - score
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'versionName', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRING, 'fromProvinceId', None, None, ), # 10
    (11, TType.I32, 'eduTypeWenli', None, None, ), # 11
    (12, TType.I32, 'batch', None, None, ), # 12
    (13, TType.I16, 'year', None, None, ), # 13
    (14, TType.I16, 'score', None, None, ), # 14
  )

  def __init__(self, versionName=None, fromProvinceId=None, eduTypeWenli=None, batch=None, year=None, score=None,):
    self.versionName = versionName
    self.fromProvinceId = fromProvinceId
    self.eduTypeWenli = eduTypeWenli
    self.batch = batch
    self.year = year
    self.score = score

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.versionName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.fromProvinceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.eduTypeWenli = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.batch = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I16:
          self.year = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I16:
          self.score = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSameScoreStat_args')
    if self.versionName is not None:
      oprot.writeFieldBegin('versionName', TType.STRING, 1)
      oprot.writeString(self.versionName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.fromProvinceId is not None:
      oprot.writeFieldBegin('fromProvinceId', TType.STRING, 10)
      oprot.writeString(self.fromProvinceId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.eduTypeWenli is not None:
      oprot.writeFieldBegin('eduTypeWenli', TType.I32, 11)
      oprot.writeI32(self.eduTypeWenli)
      oprot.writeFieldEnd()
    if self.batch is not None:
      oprot.writeFieldBegin('batch', TType.I32, 12)
      oprot.writeI32(self.batch)
      oprot.writeFieldEnd()
    if self.year is not None:
      oprot.writeFieldBegin('year', TType.I16, 13)
      oprot.writeI16(self.year)
      oprot.writeFieldEnd()
    if self.score is not None:
      oprot.writeFieldBegin('score', TType.I16, 14)
      oprot.writeI16(self.score)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.versionName)
    value = (value * 31) ^ hash(self.fromProvinceId)
    value = (value * 31) ^ hash(self.eduTypeWenli)
    value = (value * 31) ^ hash(self.batch)
    value = (value * 31) ^ hash(self.year)
    value = (value * 31) ^ hash(self.score)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSameScoreStat_result(object):
  """
  Attributes:
   - success
   - namedError
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(SameScoreStat, SameScoreStat.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'namedError', (ipin.rpc.common.ttypes.NamedError, ipin.rpc.common.ttypes.NamedError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, namedError=None,):
    self.success = success
    self.namedError = namedError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype180, _size177) = iprot.readListBegin()
          for _i181 in xrange(_size177):
            _elem182 = SameScoreStat()
            _elem182.read(iprot)
            self.success.append(_elem182)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.namedError = ipin.rpc.common.ttypes.NamedError()
          self.namedError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSameScoreStat_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter183 in self.success:
        iter183.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.namedError is not None:
      oprot.writeFieldBegin('namedError', TType.STRUCT, 1)
      self.namedError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.namedError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
