#!/usr/bin/python
# coding=utf-8

import jieba
import re
import time
# jieba.enable_parallel(4)
jieba.initialize()
def cut_with_stop_words(doc, stop_words=['\n', '\s', '\t']):
    stop_re = '[' + "".join(stop_words) + ']'
    return jieba.cut(re.subn(stop_re, "", doc)[0])


if __name__ == '__main__':
    doc = u"大家可能会有疑问，经过这么多步骤搞这么麻烦，不就是为了得到个 0 1 字符串吗？" \
          u"我直接把这个文本作为字符串输入，用hash函数生成 0 1 值更简单。其实不是这样的，" \
          u"传统hash函数解决的是生成唯一值，比如 md5、hashmap等。大家可能会有疑问，经过这么多步骤搞这么麻烦，不就是为了得到个 0 1 字符串吗？" \
          u"我直接把这个文本作为字符串输入，用hash函数生成 0 1 值更简单。其实不是这样的，" \
          u"传统hash函数解决的是生成唯一值，比如 md5、hashmap等大家可能会有疑问，经过这么多步骤搞这么麻烦，不就是为了得到个 0 1 字符串吗？" \
          u"我直接把这个文本作为字符串输入，用hash函数生成 0 1 值更简单。其实不是这样的，" \
          u"传统hash函数解决的是生成唯一值，比如 md5、hashmap等大家可能会有疑问，经过这么多步骤搞这么麻烦，不就是为了得到个 0 1 字符串吗？" \
          u"我直接把这个文本作为字符串输入，用hash函数生成 0 1 值更简单。其实不是这样的，" \
          u"传统hash函数解决的是生成唯一值，比如 md5、hashmap等大家可能会有疑问，经过这么多步骤搞这么麻烦，不就是为了得到个 0 1 字符串吗？" \
          u"我直接把这个文本作为字符串输入，用hash函数生成 0 1 值更简单。其实不是这样的，" \
          u"传统hash函数解决的是生成唯一值，比如 md5、hashmap等大家可能会有疑问，经过这么多步骤搞这么麻烦，不就是为了得到个 0 1 字符串吗？" \
          u"我直接把这个文本作为字符串输入，用hash函数生成 0 1 值更简单。其实不是这样的，" \
          u"传统hash函数解决的是生成唯一值，比如 md5、hashmap等大家可能会有疑问，经过这么多步骤搞这么麻烦，不就是为了得到个 0 1 字符串吗？" \
          u"我直接把这个文本作为字符串输入，用hash函数生成 0 1 值更简单。其实不是这样的，" \
          u"传统hash函数解决的是生成唯一值，比如 md5、hashmap等大家可能会有疑问，经过这么多步骤搞这么麻烦，不就是为了得到个 0 1 字符串吗？" \
          u"我直接把这个文本作为字符串输入，用hash函数生成 0 1 值更简单。其实不是这样的，" \
          u"传统hash函数解决的是生成唯一值，比如 md5、hashmap等大家可能会有疑问，经过这么多步骤搞这么麻烦，不就是为了得到个 0 1 字符串吗？" \
          u"我直接把这个文本作为字符串输入，用hash函数生成 0 1 值更简单。其实不是这样的，" \
          u"传统hash函数解决的是生成唯一值，比如 md5、hashmap等大家可能会有疑问，经过这么多步骤搞这么麻烦，不就是为了得到个 0 1 字符串吗？" \
          u"我直接把这个文本作为字符串输入，用hash函数生成 0 1 值更简单。其实不是这样的，" \
          u"传统hash函数解决的是生成唯一值，比如 md5、hashmap等"
    start = time.time()
    for token in cut_with_stop_words(doc, ['1', ',', '\n', '\s', '\t']):
        print token
    print time.time() - start

